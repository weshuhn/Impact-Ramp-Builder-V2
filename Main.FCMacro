# FreeCAD and PySide Imports
import FreeCAD
import FreeCADGui
import Assembly
import Part
import time
import json
import sys
import math
import shutil
import os
import math
from PySide import QtCore, QtGui

class Box:
    def __init__(self, current_x, current_y, index, name,heading, length=0, width=0):
        self.LW_dict = {
            "8ft": {"length": 96, "width": 48},
            "12ft": {"length": 144, "width": 48},
            "16ft": {"length": 192, "width": 48},
            "LAN": {"length": 48, "width": 48},
            "TL": {"length": 60, "width": 60}, # Example Turn Landing size
            "TR": {"length": 60, "width": 60},
            "UTURN": {"length": 60, "width": 96} # U-turns are usually double width
        }
        
        self.current_x = current_x
        self.current_y = current_y
        self.index = index
        self.name = name
        self.heading = heading % 360 # 0, 90, 180, 270
        
        # Parse the 05_XX_05 naming convention
        parts = name.split("_")
        parts += [None] * (3 - len(parts))
        self.start, self.type, self.end = parts[:3]

        # KEEP CUSTOM LENGTH/WIDTH LOGIC
        if length != 0 or width != 0:
            self.width = width
            self.length = length
        else:
            # Fallback to dictionary based on the "type" from the name
            lookup_key = self.type if self.type in self.LW_dict else "8ft"
            dims = self.LW_dict[lookup_key]
            self.length = dims["length"]
            self.width = dims["width"]

        self.cords = {
            "Back_Left": {"x": 0, "y": 0},
            "Back_Right": {"x": 0, "y": 0},
            "Top_Left": {"x": 0, "y": 0},
            "Top_Right": {"x": 0, "y": 0},
            "Mid_Left": None, # For 12ft and 16ft support
            "Mid_Right": None
        }

        # Run calculations
        self.calculate_all_posts()

    def rotate_point(self, local_x, local_y):
        """Converts local box coordinates to global grid coordinates based on heading"""
        rad = math.radians(self.heading)
        # Rotation Matrix
        rot_x = local_x * math.cos(rad) - local_y * math.sin(rad)
        rot_y = local_x * math.sin(rad) + local_y * math.cos(rad)
        
        return (self.current_x + rot_x, self.current_y + rot_y)

    def calculate_all_posts(self):
        # 1. Determine local offsets (distance from the "Center Line" of the ramp)
        # We assume current_x/y is the center of the start edge
        half_w = self.width / 2
        
        # Start (Back) Offset Logic
        start_y_off = 1.75 if self.start == "05" else 0
        # End (Top) Offset Logic
        end_y_off = 1.75 if self.end == "05" else 0

        # BACK LEFT (Local)
        bl_x, bl_y = self.rotate_point(-(half_w - 1.75), start_y_off)
        self.cords["Back_Left"] = {"x": bl_x, "y": bl_y}

        # BACK RIGHT (Local)
        br_x, br_y = self.rotate_point((half_w - 1.75), start_y_off)
        self.cords["Back_Right"] = {"x": br_x, "y": br_y}

        # TOP LEFT (Local)
        tl_x, tl_y = self.rotate_point(-(half_w - 1.75), self.length - end_y_off)
        self.cords["Top_Left"] = {"x": tl_x, "y": tl_y}

        # TOP RIGHT (Local)
        tr_x, tr_y = self.rotate_point((half_w - 1.75), self.length - end_y_off)
        self.cords["Top_Right"] = {"x": tr_x, "y": tr_y}

        # MIDDLE POSTS (For 12ft and 16ft)
        if self.length > 96:
            ml_x, ml_y = self.rotate_point(-(half_w - 1.75), self.length / 2)
            mr_x, mr_y = self.rotate_point((half_w - 1.75), self.length / 2)
            self.cords["Mid_Left"] = {"x": ml_x, "y": ml_y}
            self.cords["Mid_Right"] = {"x": mr_x, "y": mr_y} 

class MainForm(QtGui.QWidget):
    def __init__(self):
        super(MainForm, self).__init__()
        
        # --- PATH FIX: Find the macro's own directory ---
        # __file__ is the path of the currently running script
        self.macro_dir = os.path.dirname(__file__) 
        json_path = os.path.join(self.macro_dir, 'Lumber_Prices.json')
        # --- END FIX ---
        
        self.lumber_prices = self.load_lumber_prices(json_path) # Pass the full path
        self.create_form_layout()

    def load_lumber_prices(self, file_path): # Changed to accept the full file_path
        """Reads the JSON file and returns the list of lumber prices."""
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
                return data.get('lumber_prices', [])
        except FileNotFoundError:
            # Now prints the full path in the error
            print(f"Error: JSON file not found at {file_path}")
            FreeCAD.Console.PrintWarning(f"Lumber_Prices.json not found at {file_path}\n")
            return []
        except json.JSONDecodeError:
            print("Error: Could not parse JSON data. Check file formatting.")
            FreeCAD.Console.PrintWarning("Error parsing Lumber_Prices.json\n")
            return []
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            FreeCAD.Console.PrintError(f"Error loading lumber prices: {e}\n")
            return []
    
    def create_form_layout(self):
        # (This function is unchanged, it just builds the UI)
        master_layout = QtGui.QHBoxLayout(self)
        form_container_layout = QtGui.QVBoxLayout()
        form_grid = QtGui.QGridLayout()
        self.heading_label = QtGui.QLabel("<h1>Basic Info</h1>")
        form_grid.addWidget(self.heading_label, 0, 0)
        self.client_label = QtGui.QLabel("Client Name:")
        self.client_input = QtGui.QLineEdit()
        form_grid.addWidget(self.client_label, 1, 0)
        form_grid.addWidget(self.client_input, 1, 1)
        self.site_label = QtGui.QLabel("Site Number:")
        self.site_input = QtGui.QLineEdit()
        form_grid.addWidget(self.site_label, 2, 0)
        form_grid.addWidget(self.site_input, 2, 1)
        self.heading_label = QtGui.QLabel("<h1>Deck/Porch Info</h1>")
        form_grid.addWidget(self.heading_label, 3, 0)
        self.inch_label = QtGui.QLabel("Input unit inches? :")
        self.inch_input = QtGui.QCheckBox()
        form_grid.addWidget(self.inch_label, 4, 0)
        form_grid.addWidget(self.inch_input, 4, 1)
        self.length_label = QtGui.QLabel("Length (Foot):")
        self.length_input = QtGui.QLineEdit()
        self.length_input.setValidator(QtGui.QIntValidator(0, 99999, parent=self))
        form_grid.addWidget(self.length_label, 5, 0)
        form_grid.addWidget(self.length_input, 5, 1)
        self.width_label = QtGui.QLabel("Width: (Foot)")
        self.width_input = QtGui.QLineEdit()
        self.width_input.setValidator(QtGui.QIntValidator(0, 99999, parent=self))
        form_grid.addWidget(self.width_label, 6, 0)
        form_grid.addWidget(self.width_input, 6, 1)
        self.Stair_Label = QtGui.QLabel("Number of Stairs:")
        self.Stair_input = QtGui.QLineEdit()
        self.Stair_input.setValidator(QtGui.QIntValidator(0, 4, parent=self))
        form_grid.addWidget(self.Stair_Label, 7, 0)
        form_grid.addWidget(self.Stair_input, 7, 1)
        self.heading_label = QtGui.QLabel("<h1>Ramp Info</h1>")
        form_grid.addWidget(self.heading_label, 8, 0)
        self.ramp_desc_label = QtGui.QLabel("Ramp :")
        self.ramp_desc_input = QtGui.QLineEdit()
        self.ramp_desc_input.setMinimumSize(250,40)
        form_grid.addWidget(self.ramp_desc_label, 9, 0)
        form_grid.addWidget(self.ramp_desc_input, 9, 1)
        self.flat_label = QtGui.QLabel("Ending flat? :")
        self.flat_input = QtGui.QCheckBox()
        form_grid.addWidget(self.flat_label, 10, 0)
        form_grid.addWidget(self.flat_input, 10, 1)
        self.heading_label = QtGui.QLabel("<h3>Slope:</h3>")
        form_grid.addWidget(self.heading_label, 11, 0)
        self.drop_label = QtGui.QLabel("Drop (Inches) :")
        self.drop_input = QtGui.QLineEdit()
        self.drop_input.setValidator(QtGui.QIntValidator(0, 10, parent=self))
        form_grid.addWidget(self.drop_label, 12, 0)
        form_grid.addWidget(self.drop_input, 12, 1)
        self.degree_label = QtGui.QLabel("Degree (Angle) :")
        self.degree_input = QtGui.QLineEdit()
        self.degree_input.setValidator(QtGui.QIntValidator(0, 10, parent=self))
        form_grid.addWidget(self.degree_label, 13, 0)
        form_grid.addWidget(self.degree_input, 13, 1)
        self.heading_label = QtGui.QLabel("<h1>Gen Info</h1>")
        form_grid.addWidget(self.heading_label, 14, 0)
        self.point_label = QtGui.QLabel("Point Cloud Post Set (optional):")
        self.point_display = QtGui.QLineEdit()
        self.point_pick = QtGui.QPushButton("Browse...")
        self.point_display.setReadOnly(True)
        form_grid.addWidget(self.point_label, 15, 0)
        form_grid.addWidget(self.point_display, 15, 1)
        form_grid.addWidget(self.point_pick, 15, 2)
        self.point_pick.clicked.connect(self.open_file_dialog)
        self.post_label = QtGui.QLabel("Normal Post Set:")
        self.post_input = QtGui.QCheckBox()
        form_grid.addWidget(self.post_label, 16, 0)
        form_grid.addWidget(self.post_input, 16, 1)
        self.submit_button = QtGui.QPushButton("Submit Data")
        self.submit_button.clicked.connect(self.submit_form)
        form_container_layout.addLayout(form_grid)
        form_container_layout.addWidget(self.submit_button)
        form_container_layout.addStretch(1)
        cost_group = QtGui.QGroupBox("Current Lumber Costs (USD)")
        cost_layout = QtGui.QGridLayout(cost_group)
        cost_row = 0
        if not self.lumber_prices:
            error_label = QtGui.QLabel("Error loading prices from file.")
            error_label.setStyleSheet("color: red;")
            cost_layout.addWidget(error_label, 0, 0, 1, 2)
        else:
            for item_data in self.lumber_prices:
                item_name = item_data.get('item', 'Unknown Item')
                item_price = item_data.get('price_usd', 0.0)
                item_label = QtGui.QLabel(f"{item_name} Cost:")
                price_input = QtGui.QLineEdit()
                price_input.setReadOnly(True)
                price_input.setText(f"${item_price:.2f}")
                setattr(self, f"cost_{item_name.replace(' ', '_').lower()}_label", item_label)
                setattr(self, f"cost_{item_name.replace(' ', '_').lower()}_input", price_input)
                cost_layout.addWidget(item_label, cost_row, 0)
                cost_layout.addWidget(price_input, cost_row, 1)
                cost_row += 1
            master_layout.addLayout(form_container_layout)
            master_layout.addSpacing(100)
            master_layout.addWidget(cost_group)

    def open_file_dialog(self):
        file_path, _ = QtGui.QFileDialog.getOpenFileName(
            self, "Select a Point Cloud File", "",
            "Point Cloud (*.E57);; Polygon File Format (*.ply);;All Files (*.*)"
        )
        if file_path:
            self.point_display.setText(file_path)
            print(f"File selected: {file_path}")
        else:
            print("File selection canceled.")

    def submit_form(self):
        # (This function is unchanged, it just validates data)
        deck=False
        ramp=False
        Client_Name = self.client_input.text()
        Site_Number = self.site_input.text()
        Inches_Deck = self.inch_input.isChecked()
        Deck_Length = self.length_input.text()
        Deck_Width = self.width_input.text()
        Stair_Number = self.Stair_input.text()
        Ramp_Desc = self.ramp_desc_input.text()
        Flat_Check = self.flat_input.isChecked()
        Drop_Slope = self.drop_input.text()
        Drop_Angle = self.degree_input.text()
        Point_Cloud = self.point_display.text()
        No_Tech_Check = self.post_input.isChecked()
        errors = []
        if not Client_Name: errors.append("Client Name cannot be empty.")
        if not Site_Number: errors.append("Site Number cannot be empty.")
        if Deck_Length != "" or Deck_Width != "" or Stair_Number != "":
            print(12234234234)
            deck=True
            if not Deck_Length: errors.append("Deck Length is required.")
            if not Deck_Width: errors.append("Deck Width is required.")
            if not Stair_Number: errors.append("Number of Stairs is required.")
        if Ramp_Desc != "" or Drop_Slope != "" or Drop_Angle != "":
            ramp=True
            if not Ramp_Desc: errors.append("Ramp Description cannot be empty.")
            if not Drop_Slope and not Drop_Angle:
                errors.append("Either 'Drop (Inches)' or 'Degree (Angle)' must be provided for the ramp slope.")
            elif Drop_Slope and Drop_Angle:
                    errors.append("Please provide only one value for the ramp slope: either 'Drop (Inches)' or 'Degree (Angle)'.")
        if errors:
            QtGui.QMessageBox.warning(
                self, "Validation Error",
                "Please correct the following errors before submitting:\n\n" + "\n".join(f"* {e}" for e in errors)
            )
            return

        
        if ramp: 
        	Drop_Slope = int(Drop_Slope) if Drop_Slope else None
        	Drop_Angle = int(Drop_Angle) if Drop_Angle else None
        if deck:
            Deck_Length = int(Deck_Length)
            Deck_Width = int(Deck_Width)
            Stair_Number = int(Stair_Number)
            # --- PATH FIX: Pass the macro_dir to the new window ---
            self.deck_designer_window = DeckDesignerWindow(
                Deck_Length, Deck_Width, Stair_Number, Inches_Deck,ramp, 
                self.macro_dir, # Pass the path
                parent=self
            )
            # --- END FIX ---
            self.deck_designer_window.show()
            print("Launched Deck Designer Window.")
            
        if ramp and not deck:
            # call to main ramp
            Gui.Control.closeDialog()
            ramp_main(Ramp_Desc,Flat_Check,Drop_Slope,Drop_Angle,Client_Name,Site_Number)
            

# deck break out
class DeckDesignerWindow(QtGui.QMainWindow):
    def __init__(self, deck_length, deck_width, stair_count, inch, ramp, macro_dir, parent=None): # <-- FIX: Added macro_dir
        super(DeckDesignerWindow, self).__init__(parent)
        self.setWindowTitle(f"Deck Designer - {deck_length} x {deck_width}")
        self.setGeometry(200, 200, 1000, 800)

        self.inch_unit=inch
        self.deck_length = deck_length
        self.deck_width = deck_width
        self.stair_count = stair_count
        self.macro_dir = macro_dir # <-- FIX: Save the path
        self.ramp = ramp
        
        self.stair_items = []

        self.central_widget = QtGui.QWidget()
        self.setCentralWidget(self.central_widget)
        self.master_layout = QtGui.QVBoxLayout(self.central_widget)
        
        self.create_design_space()
        
    def create_design_space(self):
        # (This function is unchanged, it just builds the UI)
        title_label = QtGui.QLabel("<h2>Deck and Ramp Placement (Top View)</h2>")
        self.master_layout.addWidget(title_label)
        control_group = QtGui.QGroupBox("Design Controls")
        control_layout = QtGui.QHBoxLayout(control_group)
        house_label = QtGui.QLabel("House Facing Side:")
        self.house_side_combo = QtGui.QComboBox()
        self.house_side_combo.addItems(["Top", "Bottom", "Left", "Right"])
        self.house_side_combo.currentTextChanged.connect(self.update_house_label)
        control_layout.addWidget(house_label)
        control_layout.addWidget(self.house_side_combo)
        control_layout.addStretch(1)
        self.build_button = QtGui.QPushButton("Build 3D Model in FreeCAD")
        self.build_button.setStyleSheet("background-color: #4CAF50; color: white; padding: 5px; font-weight: bold;")
        self.build_button.clicked.connect(self.build_in_freecad)
        control_layout.addWidget(self.build_button)
        self.master_layout.addWidget(control_group)
        self.scene = QtGui.QGraphicsScene()
        self.view = QtGui.QGraphicsView(self.scene)
        self.view.setRenderHint(QtGui.QPainter.Antialiasing)
        self.master_layout.addWidget(self.view)
        self.draw_deck()
        self.add_components()
        self.house_label_item = None
        self.update_house_label(self.house_side_combo.currentText())

    def build_in_freecad(self):
        # (This function is unchanged, it just builds the 3D parts)
        print("Building 3D model in FreeCAD...")
        house_side = self.house_side_combo.currentText()
        print(f"House on {house_side} side.")
        if self.inch_unit:
            deck_l_mm = self.deck_length * 25.4
            deck_w_mm = self.deck_width * 25.4
        else:
            deck_l_mm = self.deck_length * 304.8
            deck_w_mm = self.deck_width * 304.8
        deck_h_mm = 152.4 
        print(f"Deck (mm): L={deck_l_mm}, W={deck_w_mm}, H={deck_h_mm}")
        try:
            doc = FreeCAD.newDocument("Deck_Project")
        except Exception:
            doc = FreeCAD.ActiveDocument
            if not doc:
                QtGui.QMessageBox.critical(self, "FreeCAD Error", "Could not create or find a FreeCAD document.")
                return
        deck_shape = Part.makeBox(deck_l_mm, deck_w_mm, deck_h_mm)
        deck_obj = doc.addObject("Part::Feature", "Deck")
        deck_obj.Shape = deck_shape
        for i, stair_item in enumerate(self.stair_items):
            pos = stair_item.pos()
            rect = stair_item.boundingRect()
            print(f"Stair {i+1} at scene pos: ({pos.x()}, {pos.y()})")
            stair_w_mm = rect.width() * 25.4 
            stair_l_mm = rect.height() * 25.4
            stair_h_mm = 152.4
            stair_shape = Part.makeBox(stair_l_mm, stair_w_mm, stair_h_mm)
            stair_obj = doc.addObject("Part::Feature", f"Stairs_{i+1}")
            stair_obj.Shape = stair_shape
            stair_obj.Placement = FreeCAD.Placement(
                FreeCAD.Vector(deck_l_mm + 500, i * (stair_w_mm + 200), 0), 
                FreeCAD.Rotation(0,0,0)
            )
        ramp_pos = self.ramp_item.pos()
        ramp_rect = self.ramp_item.boundingRect()
        print(f"Ramp at scene pos: ({ramp_pos.x()}, {ramp_pos.y()})")
        ramp_w_mm = ramp_rect.width() * 25.4
        ramp_l_mm = ramp_rect.height() * 25.4
        ramp_h_mm = 152.4
        ramp_shape = Part.makeBox(ramp_l_mm, ramp_w_mm, ramp_h_mm)
        ramp_obj = doc.addObject("Part::Feature", "Ramp")
        ramp_obj.Shape = ramp_shape
        ramp_obj.Placement = FreeCAD.Placement(
            FreeCAD.Vector(deck_l_mm + 500, -ramp_w_mm - 200, 0), 
            FreeCAD.Rotation(0,0,0)
        )
        doc.recompute()
        FreeCADGui.SendMsgToActiveView("ViewFit")
        print("Build complete. Closing windows.")
        self.close()
        FreeCADGui.Control.closeDialog()

    def update_house_label(self, side: str):
        # (This function is unchanged, it just draws the "HOUSE" text)
        if self.house_label_item:
            self.scene.removeItem(self.house_label_item)
            self.house_label_item = None
        if not hasattr(self, 'deck_rect') or not self.deck_rect:
            return
        deck_rect = self.deck_rect.rect()
        label_text = "HOUSE"
        label = QtGui.QGraphicsTextItem(label_text)
        label.setDefaultTextColor(QtGui.QColor(255, 0, 0))
        font = label.font()
        font.setPointSize(20)
        font.setBold(True)
        label.setFont(font)
        label_bounds = label.boundingRect()
        if side == "Top":
            x = deck_rect.left() + (deck_rect.width() - label_bounds.width()) / 2
            y = deck_rect.top() - label_bounds.height()
        elif side == "Bottom":
            x = deck_rect.left() + (deck_rect.width() - label_bounds.width()) / 2
            y = deck_rect.bottom()
        elif side == "Left":
            x = deck_rect.left() - label_bounds.width()
            y = deck_rect.top() + (deck_rect.height() - label_bounds.height()) / 2
            label.setRotation(-90)
            x += label_bounds.height()
        elif side == "Right":
            x = deck_rect.right()
            y = deck_rect.top() + (deck_rect.height() - label_bounds.height()) / 2
            label.setRotation(90)
            y += label_bounds.width()
        else:
            return
        label.setPos(x, y)
        self.scene.addItem(label)
        self.house_label_item = label
        
    def draw_deck(self):
        self.scene.clear()
        
        if self.inch_unit:
            SCALE = 1
        else:
            SCALE = 10 
        
        visual_length = self.deck_length * SCALE
        visual_width = self.deck_width * SCALE
        
        try:
            # --- PATH FIX: Use absolute path for texture ---
            texture_path = os.path.join(self.macro_dir, "Decking.png")
            texture_pixmap = QtGui.QPixmap(texture_path)
            # --- END FIX ---
            
            if texture_pixmap.isNull():
                print(f"Warning: Texture image 'Decking.png' not found at {texture_path}")
                deck_brush = QtGui.QBrush(QtGui.QColor(190, 190, 250, 100))
            else:
                scaled_pixmap = texture_pixmap.scaled(
                    visual_length, visual_width,
                    QtCore.Qt.IgnoreAspectRatio, QtCore.Qt.SmoothTransformation
                )
                deck_brush = QtGui.QBrush(scaled_pixmap)
                
        except Exception as e:
            print(f"Error loading texture: {e}. Falling back to solid color.")
            deck_brush = QtGui.QBrush(QtGui.QColor(190, 190, 250, 100))

        self.deck_rect = QtGui.QGraphicsRectItem(0, 0, visual_length, visual_width)
        self.deck_rect.setBrush(deck_brush)
        self.scene.addItem(self.deck_rect)
        
        label = QtGui.QGraphicsTextItem(f"Deck Area\n{self.deck_length} x {self.deck_width}")
        label.setDefaultTextColor(QtGui.QColor(0, 0, 100))
        label.setPos(visual_length / 2 - label.boundingRect().width() / 2,
                     visual_width / 2 - label.boundingRect().height() / 2)
        self.scene.addItem(label)
        
        self.scene.setSceneRect(QtCore.QRectF(self.deck_rect.rect()).normalized().adjusted(-10, -10, 10, 10))
        self.view.fitInView(self.scene.sceneRect(), QtCore.Qt.KeepAspectRatio)

    def add_components(self):
        deck_item = self.deck_rect
        
        if self.stair_count > 0:
            print(self.ramp)
            initial_x_offset = 0
            for i in range(self.stair_count):
                # --- PATH FIX: Pass macro_dir to item ---
                stairs = StairsItem(self.inch_unit, index=i + 1, deck_item=deck_item, macro_dir=self.macro_dir)
                # --- END FIX ---
                stairs.setPos(initial_x_offset, 0)
                initial_x_offset += stairs.boundingRect().width()
                self.scene.addItem(stairs)
                self.stair_items.append(stairs)
        if self.ramp:
	        ramp = RampItem(self.inch_unit, deck_item=deck_item, macro_dir=self.macro_dir)
	        ramp_x_pos = deck_item.rect().width() - ramp.boundingRect().width()
	        ramp.setPos(ramp_x_pos, 0)
	        self.scene.addItem(ramp)
	        self.ramp_item = ramp
        
class DraggableItem(QtGui.QGraphicsRectItem):
    # --- PATH FIX: Accept macro_dir and use it to build texture_path ---
    def __init__(self, rect, color, name="Item", deck_item=None, texture_path=None, parent=None):
        # Note: texture_path here is now the *full, absolute path*
        # It was constructed in StairsItem and RampItem
        super(DraggableItem, self).__init__(rect, parent)
        self.name = name
        self.deck_item = deck_item
        
        self.setFlag(QtGui.QGraphicsRectItem.ItemIsMovable)
        self.setCacheMode(QtGui.QGraphicsRectItem.DeviceCoordinateCache)

        brush = QtGui.QBrush(QtGui.QColor(color))
        
        if texture_path: # texture_path is already the full path
            try:
                texture_pixmap = QtGui.QPixmap(texture_path) 
                if not texture_pixmap.isNull():
                    scaled_pixmap = texture_pixmap.scaled(
                        rect.width(), rect.height,
                        QtCore.Qt.IgnoreAspectRatio, QtCore.Qt.SmoothTransformation
                    )
                    brush = QtGui.QBrush(scaled_pixmap)
                else:
                    print(f"Warning: Texture image not found at '{texture_path}'")
            except Exception as e:
                print(f"Error loading texture for {self.name}: {e}. Using solid color.")

        self.setBrush(brush)
        self.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0), 1))
        self.add_label()
        
    def add_label(self):
        # (This function is unchanged)
        label = QtGui.QGraphicsTextItem(self.name, parent=self)
        label.setDefaultTextColor(QtGui.QColor(0, 0, 0))
        item_rect = self.boundingRect()
        label_bounds = label.boundingRect()
        x = item_rect.width() / 2 - label_bounds.width() / 2
        y = item_rect.height() / 2 - label_bounds.height() / 2
        label.setPos(x, y)
        
    def mousePressEvent(self, event):
        # (This function is unchanged)
        super(DraggableItem, self).mousePressEvent(event)
        print(f"Clicked and dragging {self.name}")

    def get_snap_positions(self):
        # (This function is unchanged)
        if not self.deck_item:
            return []
        deck_rect = self.deck_item.rect()
        item_w = self.boundingRect().width()
        item_h = self.boundingRect().height()
        positions = []
        positions.append(QtCore.QPointF(deck_rect.left(), deck_rect.top() - item_h))
        positions.append(QtCore.QPointF(deck_rect.left() - item_w, deck_rect.top()))
        positions.append(QtCore.QPointF(deck_rect.right() - item_w, deck_rect.top() - item_h))
        positions.append(QtCore.QPointF(deck_rect.right(), deck_rect.top()))
        positions.append(QtCore.QPointF(deck_rect.right() - item_w, deck_rect.bottom()))
        positions.append(QtCore.QPointF(deck_rect.right(), deck_rect.bottom() - item_h))
        positions.append(QtCore.QPointF(deck_rect.left(), deck_rect.bottom()))
        positions.append(QtCore.QPointF(deck_rect.left() - item_w, deck_rect.bottom() - item_h))
        return positions
        
    def mouseReleaseEvent(self, event):
        # (This function is unchanged)
        super(DraggableItem, self).mouseReleaseEvent(event)
        current_pos = self.pos()
        snap_positions = self.get_snap_positions()
        if not snap_positions:
            return
        min_distance_sq = float('inf')
        nearest_pos = current_pos
        for snap_pos in snap_positions:
            dx = snap_pos.x() - current_pos.x()
            dy = snap_pos.y() - current_pos.y()
            distance_sq = dx*dx + dy*dy
            if distance_sq < min_distance_sq:
                min_distance_sq = distance_sq
                nearest_pos = snap_pos
        self.setPos(nearest_pos)
        print(f"{self.name} snapped to: ({nearest_pos.x():.2f}, {nearest_pos.y():.2f})")

class StairsItem(DraggableItem):
    # --- PATH FIX: Accept macro_dir and build full path ---
    def __init__(self, scale, index=1, deck_item=None, macro_dir="", parent=None):
        full_texture_path = os.path.join(macro_dir, "Stair_T.png")
        super(StairsItem, self).__init__(
            QtCore.QRectF(0, 0, 36, 36),
            QtGui.QColor(255, 150, 50, 200),
            f"STAIRS {index}",
            deck_item=deck_item,
            texture_path=full_texture_path, # Pass the full path
            parent=parent
        )
        
class RampItem(DraggableItem):
    # --- PATH FIX: Accept macro_dir and build full path ---
    def __init__(self,scale, deck_item=None, macro_dir="", parent=None):
            full_texture_path = os.path.join(macro_dir, "Ramp_T.png")
            super(RampItem, self).__init__(
                QtCore.QRectF(0, 0, 48, 48),
                QtGui.QColor(50, 200, 50, 200),
                "RAMP",
                deck_item=deck_item,
                texture_path=full_texture_path, # Pass the full path
                parent=parent
            )
            

def import_ramp_part(main_file_path, index, part, start_angle, end_angle):
    # 1. Setup paths
    source_file = r"C:\Users\weshu\OneDrive\Desktop\IMPACT Assets\Big Rework\Parts\All parts made\8ft_Main.FCStd"
    temp_file = f"C:/Users/weshu/OneDrive/Desktop/IMPACT Assets/Big Rework/Temp/{index}_{part}.FCStd"
    nested_link = None
    # 2. Create the modified part file
    # We open the source, save a copy, close source, open the copy
    src_doc = App.openDocument(source_file)
    src_doc.saveCopy(temp_file)
    App.closeDocument(src_doc.Name)
    
    sub_doc = App.openDocument(temp_file)
    
    # 3. Update Spreadsheet values
    sheet = sub_doc.getObject("Spreadsheet001")
    if sheet:
        sheet.set("start_angle", str(start_angle))
        sheet.set("end_angle", str(end_angle))
        sub_doc.recompute()
    sub_doc.save() # Ensure changes are written to disk

    # 4. Get the Main Assembly Document
    # Use openDocument to get the object, then ensure we have the Assembly container
    main_doc = App.openDocument(main_file_path)
    main_asm = main_doc.getObject("Assembly") # This is the object we created in the last step
    
    if not main_asm:
        print("Error: Main Assembly container not found in the main file.")
        return

    # 5. Create a Link to the sub-document's content
    # In the integrated workbench, we usually link the 'Assembly' object of the sub-file
    sub_asm_obj = None
    for obj in sub_doc.Objects:
        # Check for the correct type we discovered: Assembly::AssemblyObject
        if obj.isDerivedFrom("Assembly::AssemblyObject"):
            sub_asm_obj = obj
            break

    if sub_asm_obj:
        # Create an App::Link in the Main Document
        link_name = f"Link_{part}_{index}"
        nested_link = main_doc.addObject("App::Link", link_name)
        nested_link.LinkedObject = sub_asm_obj
        
        # Move the link into the Main Assembly container
        main_asm.Group = main_asm.Group + [nested_link]
    
        print(f"Successfully linked {part} into Main Assembly.")
    else:
        print(f"Could not find a valid object to link in {temp_file}")

    main_doc.recompute()
    main_doc.save()
    return nested_link
        

def advance_cursor(x, y, heading_deg, forward, lateral=0.0):
    rad = math.radians(heading_deg)

    # Forward along heading
    x_fwd = x + forward * math.cos(rad)
    y_fwd = y + forward * math.sin(rad)

    # Lateral left/right (left is +, right is -)
    # Left vector = heading rotated +90° → (-sin, +cos)
    x_lat = x_fwd + lateral * (-math.sin(rad))
    y_lat = y_fwd + lateral * ( math.cos(rad))

    return x_lat, y_lat


def find_joint_group(asm_obj):
    """Return the Assembly::JointGroup child of the assembly."""
    for child in getattr(asm_obj, "Group", []):
        tid = getattr(child, "TypeId", "")
        if tid == "Assembly::JointGroup" or child.isDerivedFrom("Assembly::JointGroup"):
            return child
    return None

def create_fixed_joint_between_links(doc, asm, joints_grp, link_a, link_b,
                                     sub_a="Binder_End", sub_b="Binder_Start",
                                     label=None):
    """
    Create a Fixed Joint between two App::Link instances that live under the master assembly.
    Selection is made on the master links, then the Assembly 'Fixed Joint' command is run.
    """
    # Build selection on the master links (not the source file objects)
    Gui.Selection.clearSelection()
    Gui.Selection.addSelection(doc.Name, link_a.Name, sub_a)
    Gui.Selection.addSelection(doc.Name, link_b.Name, sub_b)

    # Make master assembly the active edit context so the joint lands in its JointGroup
    try:
        Gui.ActiveDocument.setEdit(asm)
    except Exception:
        pass

    before = len(joints_grp.Group)
    Gui.runCommand('Assembly_CreateJointFixed')  # Assembly → Fixed Joint
    doc.recompute()
    after = len(joints_grp.Group)

    if after <= before:
        FreeCAD.Console.PrintError(
            f"Joint creation failed for {link_a.Name} → {link_b.Name} (sub: {sub_a}, {sub_b})\n"
        )
        return None

    new_joint = joints_grp.Group[-1]
    new_joint.Type = "Fixed"  # command sets it; enforce for clarity
    if label:
        new_joint.Label = label
    doc.recompute()
    return new_joint

    
def ramp_main(desc,ending_flat,Drop_Slope,Drop_Angle,client,site_number):
    parts_to_import= {}
    parced_desc=desc.split(",")
    feet_of_ramp=0
    for i in parced_desc:
        if i == "8ft":
            feet_of_ramp+=8
        elif i == "12ft":
            feet_of_ramp+=12
        elif i == "16ft":
            feet_of_ramp+=16
    
    # Slope
    if (Drop_Slope != None): # inch of feet
        angle_radians = math.atan(Drop_Slope / (feet_of_ramp*12))
        angle=math.degrees(angle_radians)
    else:
        angle=Drop_Angle
    
    
    
    # CREATING THE MASTER Assembly
    

    # 1. Force the Assembly Module to initialize
    # This registers 'Assembly::AssemblyObject' so addObject can find it
    try:
        import Assembly
        # Some versions require the Workbench to be initialized to register types
        if App.GuiUp:
            Gui.activateWorkbench("AssemblyWorkbench")
    except ImportError:
        App.Console.PrintError("Assembly Workbench not found. Please ensure FreeCAD 1.0+ is installed.\n")

    # 2. Create your document
    doc = App.newDocument(f"{client}_{site_number}")

    # 3. Create the Assembly Container using the formal Wiki type
    try:
        # Based on the documentation: 'Assembly::AssemblyObject'
        asm = doc.addObject("Assembly::AssemblyObject", "Assembly")
        asm.Label = f"Assembly_{client}"
    
    # Trigger a recompute to generate the default 'Origin' and 'Joints' 
    # containers mentioned in the wiki.
        doc.recompute()
    
    except Exception as e:
        App.Console.PrintError(f"Error creating assembly object: {str(e)}\n")

    # 4. Save the file
    main_file = f"C:/Users/weshu/OneDrive/Desktop/IMPACT Assets/Big Rework/Temp/{client}_{site_number}.FCStd"
    doc.saveAs(main_file)
    
    flat="LAN","TL","TR","UTURNL","UTURNR"
    ramp="8ft","12ft","16ft"
    boxes={}
    current_x = 0
    current_y = 0
    current_heading = 0
    #
    # Allways send angle
    # current_x, current_y, index, name, length=0, width=0, heading=0
    for index,part in enumerate(parced_desc):
      
        if index > 0:  	
        	part_before = parced_desc[index - 1]
        if index < len(parced_desc) - 1:
        	part_after = parced_desc[index + 1]
        # if part first
        print("inde x  "+str(index))
        if (index == 0):
            current_x=0
            current_y=0
            if (part in ramp):
            	if (part_after in flat):
                		# 05_XX_05
            		parts_to_import[index]="A_"+part+"_A"
            		boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"A_"+part+"_A",current_heading)
            	elif (part_after in ramp):
                   		# 05_XX
                   		parts_to_import[index]="A_"+part
                   		boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"A_"+part,current_heading)
            else:
            	parts_to_import[index]=part
            	boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part,current_heading)
        # Last // ENDING   
        elif (index == len(parced_desc)-1):
            if (part_before in flat):
                # 05_XX_ ENDING
                parts_to_import[index]="A_"+part+"_END"
                boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"A_"+part+"_END",current_heading)
            else:
                # __XX_ ENDING
                parts_to_import[index]=""+part+"_END"
                boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part+"_END",current_heading)
        #normal
        # btween 2 flat
        elif (part_before in flat and part in ramp and part_after in flat):
        	# 05_XX_05
        	parts_to_import[index]="A_"+part+"_A"
        	boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"A_"+part+"_A",current_heading)
        # one side angled:
        elif (((part_before in flat) or (part_after in flat)) and part in ramp):
            if (part_before in flat):
                # 05_XX
                parts_to_import[index]="_A"+part
                boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"_A"+part,current_heading)
            else:
                # XX_05
                parts_to_import[index]=part+"_A"
                boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part+"_A",current_heading)
        elif (part_before in ramp and part in ramp and part_after in ramp):
            # XX normal RAMP
            parts_to_import[index]=part
            boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part,current_heading)
        elif (part in flat):
            # place flats
            parts_to_import[index]=part
            boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part,current_heading)
        else:
            print("NO NO NO NO - A part was NOT imported HELP HELP HELP"+part)
        # curs
        # should always be the top center line
        length = boxes[f"{index}_{part}"].length
        width = boxes[f"{index}_{part}"].width

        # Compute movement and heading updates per part type
        if part in ("8ft", "12ft", "16ft", "LAN"):
        # Straight run or inline landing: advance full length
            current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length, lateral=0.0)

        elif part == "TL":
            # 90° left turn landing: half forward, then left by width/2, then rotate left
            current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length/2.0, lateral=+width/2.0)
            current_heading = (current_heading - 90) % 360

        elif part == "TR":
            # 90° right turn landing: half forward, then right by width/2, then rotate right
            current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length/2.0, lateral=-width/2.0)
            current_heading = (current_heading + 90) % 360

        elif part == "UTURN":
           # 180° turn landing: choose your intent.
           # Option A (exit from far edge center): full forward, then rotate 180°
           current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length, lateral=0.0)
           current_heading = (current_heading + 180) % 360

           # Option B (exit from midline): half forward, rotate 180°
           # current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length/2.0, lateral=0.0)
           # current_heading = (current_heading + 180) % 360

        else:
           print("Unknown part type for cursor logic:", part)
    # List for imported links into master
    part_links = []
    for key,value in parts_to_import.items():
        
        #
        # RAMP POST alg
        # Create a SET of 
        #
        
        if  "8ft" in value:
            if "A_8ft_A" == value:
                new_link = import_ramp_part(main_file,key,"8ft",angle,angle)
            elif "A_8ft" == value:
                new_link = import_ramp_part(main_file,key,"8ft",angle,0)
            elif "8ft_A" == value:
                new_link = import_ramp_part(main_file,key,"8ft",0,angle)
            elif "8ft" == value:
                new_link = import_ramp_part(main_file,key,"8ft",0,0)
            elif "END" in value:
                #A_"+part+"END
                #"+part+"END
                if ending_flat:
                    if "A_8ft_END" == value:
                        print("you NEED TO ADD THIS")
                    elif "8ft_END" == value:
                        print("you NEED TO ADD THIS")
                    else:
                        print("BAD BAD BAD : "+value)
                else:
                    if "A_8ft_END":
                        print("someing")
                    elif "8ft_END":
                        print("see")
                    else:
                        print("BAD BAD BAD : "+value)
            else:
                print("BAD BAD BAD : "+value)
        elif  "12ft" in value:
            print("hui")
        elif  "16ft" in value:         
            print("hui")       
        
        #
        # Add link to be connected
        if new_link:
           part_links.append(new_link)
    
    #assemble main assembly
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

# --- Prep: ensure we have doc, asm, and the master JointGroup -----------------

    doc = FreeCAD.ActiveDocument
    if doc is None:
        raise RuntimeError("No active FreeCAD document.")

# If 'asm' already exists from earlier code, keep it; otherwise find the master assembly container.
    try:
        asm  # check if variable is already in scope
    except NameError:
        asm = next((o for o in doc.Objects if getattr(o, "TypeId", "") == "Assembly::AssemblyObject"), None)
    if asm is None:
        raise RuntimeError("Master Assembly container not found in the active document.")

# Helper to find the JointGroup ("Joints" container) under the assembly
    def find_joint_group(asm_obj):
        for child in getattr(asm_obj, "Group", []):
            tid = getattr(child, "TypeId", "")
            if tid == "Assembly::JointGroup" or child.isDerivedFrom("Assembly::JointGroup"):
                return child
        return None
    # GROUND @####################
    first_link = part_links[0]
    if App.GuiUp:
        Gui.activateWorkbench("AssemblyWorkbench")
        # Puts the assembly into 'edit' context so it can receive constraints
        Gui.ActiveDocument.setEdit(asm)
    
    # 1. Select the first link
    Gui.Selection.clearSelection()
    # Grounding usually targets the object itself, not a specific face
    Gui.Selection.addSelection(doc.Name, first_link.Name)
    
    # 2. Run the Ground command
    # This command toggles the 'Grounded' status of the selected element
    is_already_grounded = getattr(first_link, "Grounded", False)
    if not is_already_grounded:
        try:
            Gui.runCommand('Assembly_ToggleGrounded',0)
            doc.recompute()
            print(f"Grounded the root element: {first_link.Name}\n")
        except Exception as e:
            print(f"Failed to ground {first_link.Name}: {str(e)}\n")
    else:
        print(f"{first_link.Label} was already grounded. Skipping toggle.")
        
    # Get (or create) the JointGroup
    joints_grp = find_joint_group(asm)
    if joints_grp is None:
        doc.recompute()
        joints_grp = find_joint_group(asm)
        if joints_grp is None:
        # Fallback: create the Joints container if this build didn't auto-create it
            joints_grp = doc.addObject("Assembly::JointGroup", "Joints")
            asm.Group = asm.Group + [joints_grp]
            doc.recompute()

# Activate the Assembly WB so joint commands are available and land in the master
    if App.GuiUp:
        Gui.activateWorkbench("AssemblyWorkbench")
        try:
            Gui.ActiveDocument.setEdit(asm)  # set master assembly as active edit context
        except Exception:
            pass
    else:
        raise RuntimeError("Assembly joint creation requires FreeCAD running with GUI up.")

# --- Loop: create Fixed joints between consecutive master links ----------------
    if App.GuiUp:
        Gui.activateWorkbench("AssemblyWorkbench")
        # Ensure the assembly is the active edit context
        Gui.ActiveDocument.setEdit(asm)

# --- Loop: create Fixed joints between consecutive master links ----------------
    
    for i in range(len(part_links) - 1):
        link_a = part_links[i]
        link_b = part_links[i + 1]

        if link_a.Name == link_b.Name:
            continue

    # 1. Clear and Select
        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(doc.Name, 'Assembly', f"{link_a.Name}.Face4")
        Gui.Selection.addSelection(doc.Name, 'Assembly', f"{link_b.Name}.Face1")
    
    # Let the GUI thread process the selection
        QtCore.QCoreApplication.processEvents()
        time.sleep(0.1)
    
        try:
        # 2. Trigger the command
            Gui.runCommand('Assembly_CreateJointFixed')
        
        # 3. Wait for the Task Panel to be registered
        # We use a short loop to ensure the GUI is ready
            while Gui.Control.activeDialog():
            # Crucial: This allows the GUI to remain responsive to your clicks
                QtCore.QCoreApplication.processEvents()
                time.sleep(0.05)
        # 4. Use the most stable way to "click" OK in FreeCAD 1.0

        except Exception as e:
            print(f"Error at Joint {i}: {str(e)}")
            if Gui.Control.activeDialog():
                Gui.Control.closeDialog() # 'False' acts as Cancel/Reject
        
    # 5. Cool-down for the solver to prevent Access Violation
        doc.recompute()
        for _ in range(10):
            QtCore.QCoreApplication.processEvents()
            time.sleep(0.02)
    """
    for i in range(len(part_links) - 1):
        link_a = part_links[i]      # App::Link under the master assembly
        link_b = part_links[i + 1]  # App::Link under the master assembly

        # Select the two sub-elements (must exist on the linked segment, via the App::Link)
        Gui.Selection.clearSelection()
        # TIP: Replace "Face4" with the exact face names discovered via manual selection (see notes)
        Gui.Selection.addSelection(doc.Name, 'Assembly', f"{link_a.Name}.Face1")
        Gui.Selection.addSelection(doc.Name, 'Assembly', f"{link_b.Name}.Face1")
        QtCore.QCoreApplication.processEvents()
        
        try:
        # 1. Trigger the command (this opens the Task Panel)
            Gui.runCommand('Assembly_CreateJointFixed')
        
        # 2. IMPORTANT: Give the solver a moment to initialize the task
            timeout = 10 
            while not Gui.Control.activeDialog() and timeout > 0:
                time.sleep(0.05)
                QtCore.QCoreApplication.processEvents()
                timeout -= 1
        
        # 3. "Click" the OK button in the Task Panel
            dlg = Gui.Control.activeDialog()
            if dlg is not None:
            # In FreeCAD 1.0, we call accept() on the dialog object itself
                dlg.accept() 
                print(f"Created joint: {link_a.Label} to {link_b.Label}")
            else:
                print(f"Warning: No active dialog found for Joint {i}")
            
        except Exception as e:
            print(f"Error at Joint {i}: {str(e)}")
            if Gui.Control.activeDialog():
                Gui.Control.reject() # Close it if it failed

        joint = joints_grp.Group[-1]           # last-added joint in master Joints
        joint.Label = f"Joint_{i}_to_{i+1}"
        joint.Type  = "Fixed"                  # enforce type (command already sets it)

    # Optional: small placement nudge (offsets are placements, not references)
    # joint.Offset2 = FreeCAD.Placement(
    #     FreeCAD.Vector(0, 0, 0),
    #     FreeCAD.Rotation(0, 0, 0)
    # )

    # Optional: inspect references (internal Names)
    # FreeCAD.Console.PrintMessage(f"  Ref1: {getattr(joint, 'Reference1', None)}\n")
    # FreeCAD.Console.PrintMessage(f"  Ref2: {getattr(joint, 'Reference2', None)}\n")
        if App.GuiUp:
            Gui.ActiveDocument.resetEdit()
        doc.recompute()
   """


    
#
# MAIN
#
class RampBuilderPanel:
    def __init__(self):
        self.form = MainForm()
panel_wrapper = RampBuilderPanel() 
FreeCADGui.Control.showDialog(panel_wrapper)
