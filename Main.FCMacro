# FreeCAD and PySide Imports
import FreeCAD
import FreeCADGui
import Assembly
import JointObject
import Part
import UtilsAssembly
import Assembly
import time
import json
import sys
import math
import shutil
import os
import math
from PySide import QtCore, QtGui


import Preferences
prefs = Preferences.preferences()
prefs.SetBool("SolveInJointCreation", False) 
prev_solve = prefs.GetBool("SolveInJointCreation", True)

import UtilsAssembly
from JointObject import Joint, ViewProviderJoint
# Helper to find the JointGroup
def find_joint_group(asm_obj):
    for child in getattr(asm_obj, "Group", []):
        tid = getattr(child, "TypeId", "")
        if tid == "Assembly::JointGroup" or child.isDerivedFrom("Assembly::JointGroup"):
            return child
    return None

class Box:
    def __init__(self, current_x, current_y, index, name,heading, length=0, width=0):
        self.LW_dict = {
            "8ft": {"length": 96, "width": 48},
            "12ft": {"length": 144, "width": 48},
            "16ft": {"length": 192, "width": 48},
            "LAN": {"length": 48, "width": 48},
            "TL": {"length": 60, "width": 60}, # Example Turn Landing size
            "TR": {"length": 60, "width": 60},
            "UTURN": {"length": 60, "width": 96} # U-turns are usually double width
        }
        
        self.current_x = current_x
        self.current_y = current_y
        self.index = index
        self.name = name
        self.heading = heading % 360 # 0, 90, 180, 270
        
        # Parse the 05_XX_05 naming convention
        parts = name.split("_")
        parts += [""] * (3 - len(parts))
        self.start, self.type, self.end = parts[:3]

        # KEEP CUSTOM LENGTH/WIDTH LOGIC
        if length != 0 or width != 0:
            self.width = width
            self.length = length
        else:
            # Fallback to dictionary based on the "type" from the name
            lookup_key = self.type if self.type in self.LW_dict else "8ft"
            dims = self.LW_dict[lookup_key]
            self.length = dims["length"]
            self.width = dims["width"]

        self.cords = {
            "Back_Left": {"x": 0, "y": 0},
            "Back_Right": {"x": 0, "y": 0},
            "Top_Left": {"x": 0, "y": 0},
            "Top_Right": {"x": 0, "y": 0},
            "Mid_Left": None, # For 12ft and 16ft support
            "Mid_Right": None
        }

        # Run calculations
        self.get_points()
    def __str__(self):
        c = self.cords
        return (f"""
[{c['Back_Left']['x']}, {c['Back_Left']['y']}] ----------- [{c['Back_Right']['x']}, {c['Back_Right']['y']}]
      |                         |
      |                         |
      |                         |
[{c['Top_Left']['x']}, {c['Top_Left']['y']}] ----------- [{c['Top_Right']['x']}, {c['Top_Right']['y']}]
""")
    
    def get_points(self):

        # South
        # box length
        
        X_mod =1
        Y_mod =1
        start_offset_y =0
        start_offset_x =0
        end_offset_y=0
        end_offset_x=0
        print(self.start, self.end)
        if (self.heading == 0):
            
            # negitive Y
            Y_mod = -1
            if ("A_" in self.start):
                start_offset_y = -1.75
            if ("_A" in self.end):
                end_offset_y = 1.75
                
        elif (self.heading == 180):
            # postive Y
            Y_mod = 1
            if ("A_" in self.start):
                start_offset_y = 1.75
            if ("_A" in self.end):
                end_offset_y = -1.75
                
        elif (self.heading == 90):
            # negtive X
            X_mod=-1
            if ("A_" in self.start):
                start_offset_x = -1.75
            if ("_A" in self.end):
                end_offset_x = 1.75
        elif (self.heading == 270):
            # postive X
            X_mod =1
            if ("A_" in self.start):
                start_offset_x = 1.75
            if ("_A" in self.end):
                end_offset_x = -1.75
        
        else:
            print("we got a directial problem YAY")
        
        if (self.heading == 0 or self.heading == 180):
            
            # top of box along X
            # given on corner
            X_offset=1.75
            
            self.cords['Back_Left']['x'] = self.current_x - X_offset - (self.width/2)
            self.cords['Back_Left']['y'] = self.current_y + start_offset_y
            
            self.cords['Back_Right']['x'] = self.current_x + X_offset + (self.width/2)
            self.cords['Back_Right']['y'] = self.current_y + start_offset_y
            
            self.cords['Top_Left']['x'] = self.current_x - X_offset - (self.width/2)
            self.cords['Top_Left']['y'] = self.current_y + end_offset_y + (self.length*Y_mod)
            
            self.cords['Top_Right']['x'] = self.current_x + X_offset + (self.width/2)
            self.cords['Top_Right']['y'] = self.current_y + end_offset_y + (self.length*Y_mod)
            
        elif (self.heading == 90 or self.heading == 270):
            # NOT CORRECNT
            # top of box along Y
            Y_offset=1.75
            
            self.cords['Back_Left']['x'] = self.current_x - X_offset - (self.width/2)
            self.cords['Back_Left']['y'] = self.current_y + start_offset_y
            
            self.cords['Back_Right']['x'] = self.current_x + X_offset + (self.width/2)
            self.cords['Back_Right']['y'] = self.current_y + start_offset_y
            
            self.cords['Top_Left']['x'] = self.current_x - X_offset - (self.width/2)
            self.cords['Top_Left']['y'] = self.current_y + end_offset_y
            
            self.cords['Top_Right']['x'] = self.current_x - X_offset - (self.width/2)
            self.cords['Top_Right']['y'] = self.current_y + end_offset_y
            
    
class MainForm(QtGui.QWidget):
    def __init__(self):
        super(MainForm, self).__init__()
        
        # --- PATH FIX: Find the macro's own directory ---
        # __file__ is the path of the currently running script
        self.macro_dir = os.path.dirname(__file__) 
        json_path = os.path.join(self.macro_dir, 'Lumber_Prices.json')
        # --- END FIX ---
        
        self.lumber_prices = self.load_lumber_prices(json_path) # Pass the full path
        self.create_form_layout()

    def load_lumber_prices(self, file_path): # Changed to accept the full file_path
        """Reads the JSON file and returns the list of lumber prices."""
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
                return data.get('lumber_prices', [])
        except FileNotFoundError:
            # Now prints the full path in the error
            print(f"Error: JSON file not found at {file_path}")
            FreeCAD.Console.PrintWarning(f"Lumber_Prices.json not found at {file_path}\n")
            return []
        except json.JSONDecodeError:
            print("Error: Could not parse JSON data. Check file formatting.")
            FreeCAD.Console.PrintWarning("Error parsing Lumber_Prices.json\n")
            return []
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            FreeCAD.Console.PrintError(f"Error loading lumber prices: {e}\n")
            return []
    
    def create_form_layout(self):
        # (This function is unchanged, it just builds the UI)
        master_layout = QtGui.QHBoxLayout(self)
        form_container_layout = QtGui.QVBoxLayout()
        form_grid = QtGui.QGridLayout()
        self.heading_label = QtGui.QLabel("<h1>Basic Info</h1>")
        form_grid.addWidget(self.heading_label, 0, 0)
        self.client_label = QtGui.QLabel("Client Name:")
        self.client_input = QtGui.QLineEdit()
        form_grid.addWidget(self.client_label, 1, 0)
        form_grid.addWidget(self.client_input, 1, 1)
        self.site_label = QtGui.QLabel("Site Number:")
        self.site_input = QtGui.QLineEdit()
        form_grid.addWidget(self.site_label, 2, 0)
        form_grid.addWidget(self.site_input, 2, 1)
        self.heading_label = QtGui.QLabel("<h1>Deck/Porch Info</h1>")
        form_grid.addWidget(self.heading_label, 3, 0)
        self.inch_label = QtGui.QLabel("Input unit inches? :")
        self.inch_input = QtGui.QCheckBox()
        form_grid.addWidget(self.inch_label, 4, 0)
        form_grid.addWidget(self.inch_input, 4, 1)
        self.length_label = QtGui.QLabel("Length (Foot):")
        self.length_input = QtGui.QLineEdit()
        self.length_input.setValidator(QtGui.QIntValidator(0, 99999, parent=self))
        form_grid.addWidget(self.length_label, 5, 0)
        form_grid.addWidget(self.length_input, 5, 1)
        self.width_label = QtGui.QLabel("Width: (Foot)")
        self.width_input = QtGui.QLineEdit()
        self.width_input.setValidator(QtGui.QIntValidator(0, 99999, parent=self))
        form_grid.addWidget(self.width_label, 6, 0)
        form_grid.addWidget(self.width_input, 6, 1)
        self.Stair_Label = QtGui.QLabel("Number of Stairs:")
        self.Stair_input = QtGui.QLineEdit()
        self.Stair_input.setValidator(QtGui.QIntValidator(0, 4, parent=self))
        form_grid.addWidget(self.Stair_Label, 7, 0)
        form_grid.addWidget(self.Stair_input, 7, 1)
        self.heading_label = QtGui.QLabel("<h1>Ramp Info</h1>")
        form_grid.addWidget(self.heading_label, 8, 0)
        self.ramp_desc_label = QtGui.QLabel("Ramp :")
        self.ramp_desc_input = QtGui.QLineEdit()
        self.ramp_desc_input.setMinimumSize(250,40)
        form_grid.addWidget(self.ramp_desc_label, 9, 0)
        form_grid.addWidget(self.ramp_desc_input, 9, 1)
        self.flat_label = QtGui.QLabel("Ending flat? :")
        self.flat_input = QtGui.QCheckBox()
        form_grid.addWidget(self.flat_label, 10, 0)
        form_grid.addWidget(self.flat_input, 10, 1)
        self.heading_label = QtGui.QLabel("<h3>Slope:</h3>")
        form_grid.addWidget(self.heading_label, 11, 0)
        self.drop_label = QtGui.QLabel("Drop (Inches) :")
        self.drop_input = QtGui.QLineEdit()
        self.drop_input.setValidator(QtGui.QIntValidator(0, 10, parent=self))
        form_grid.addWidget(self.drop_label, 12, 0)
        form_grid.addWidget(self.drop_input, 12, 1)
        self.degree_label = QtGui.QLabel("Degree (Angle) :")
        self.degree_input = QtGui.QLineEdit()
        self.degree_input.setValidator(QtGui.QIntValidator(0, 10, parent=self))
        form_grid.addWidget(self.degree_label, 13, 0)
        form_grid.addWidget(self.degree_input, 13, 1)
        self.heading_label = QtGui.QLabel("<h1>Gen Info</h1>")
        form_grid.addWidget(self.heading_label, 14, 0)
        self.point_label = QtGui.QLabel("Point Cloud Post Set (optional):")
        self.point_display = QtGui.QLineEdit()
        self.point_pick = QtGui.QPushButton("Browse...")
        self.point_display.setReadOnly(True)
        form_grid.addWidget(self.point_label, 15, 0)
        form_grid.addWidget(self.point_display, 15, 1)
        form_grid.addWidget(self.point_pick, 15, 2)
        self.point_pick.clicked.connect(self.open_file_dialog)
        self.post_label = QtGui.QLabel("Normal Post Set:")
        self.post_input = QtGui.QCheckBox()
        form_grid.addWidget(self.post_label, 16, 0)
        form_grid.addWidget(self.post_input, 16, 1)
        self.submit_button = QtGui.QPushButton("Submit Data")
        self.submit_button.clicked.connect(self.submit_form)
        form_container_layout.addLayout(form_grid)
        form_container_layout.addWidget(self.submit_button)
        form_container_layout.addStretch(1)
        cost_group = QtGui.QGroupBox("Current Lumber Costs (USD)")
        cost_layout = QtGui.QGridLayout(cost_group)
        cost_row = 0
        if not self.lumber_prices:
            error_label = QtGui.QLabel("Error loading prices from file.")
            error_label.setStyleSheet("color: red;")
            cost_layout.addWidget(error_label, 0, 0, 1, 2)
        else:
            for item_data in self.lumber_prices:
                item_name = item_data.get('item', 'Unknown Item')
                item_price = item_data.get('price_usd', 0.0)
                item_label = QtGui.QLabel(f"{item_name} Cost:")
                price_input = QtGui.QLineEdit()
                price_input.setReadOnly(True)
                price_input.setText(f"${item_price:.2f}")
                setattr(self, f"cost_{item_name.replace(' ', '_').lower()}_label", item_label)
                setattr(self, f"cost_{item_name.replace(' ', '_').lower()}_input", price_input)
                cost_layout.addWidget(item_label, cost_row, 0)
                cost_layout.addWidget(price_input, cost_row, 1)
                cost_row += 1
            master_layout.addLayout(form_container_layout)
            master_layout.addSpacing(100)
            master_layout.addWidget(cost_group)

    def open_file_dialog(self):
        file_path, _ = QtGui.QFileDialog.getOpenFileName(
            self, "Select a Point Cloud File", "",
            "Point Cloud (*.E57);; Polygon File Format (*.ply);;All Files (*.*)"
        )
        if file_path:
            self.point_display.setText(file_path)
            print(f"File selected: {file_path}")
        else:
            print("File selection canceled.")

    def submit_form(self):
        # (This function is unchanged, it just validates data)
        deck=False
        ramp=False
        Client_Name = self.client_input.text()
        Site_Number = self.site_input.text()
        Inches_Deck = self.inch_input.isChecked()
        Deck_Length = self.length_input.text()
        Deck_Width = self.width_input.text()
        Stair_Number = self.Stair_input.text()
        Ramp_Desc = self.ramp_desc_input.text()
        Flat_Check = self.flat_input.isChecked()
        Drop_Slope = self.drop_input.text()
        Drop_Angle = self.degree_input.text()
        Point_Cloud = self.point_display.text()
        No_Tech_Check = self.post_input.isChecked()
        errors = []
        if not Client_Name: errors.append("Client Name cannot be empty.")
        if not Site_Number: errors.append("Site Number cannot be empty.")
        if Deck_Length != "" or Deck_Width != "" or Stair_Number != "":
            deck=True
            if not Deck_Length: errors.append("Deck Length is required.")
            if not Deck_Width: errors.append("Deck Width is required.")
            if not Stair_Number: errors.append("Number of Stairs is required.")
        if Ramp_Desc != "" or Drop_Slope != "" or Drop_Angle != "":
            ramp=True
            if not Ramp_Desc: errors.append("Ramp Description cannot be empty.")
            if not Drop_Slope and not Drop_Angle:
                errors.append("Either 'Drop (Inches)' or 'Degree (Angle)' must be provided for the ramp slope.")
            elif Drop_Slope and Drop_Angle:
                    errors.append("Please provide only one value for the ramp slope: either 'Drop (Inches)' or 'Degree (Angle)'.")
        if errors:
            QtGui.QMessageBox.warning(
                self, "Validation Error",
                "Please correct the following errors before submitting:\n\n" + "\n".join(f"* {e}" for e in errors)
            )
            return

        # CREATING THE MASTER FILE

        doc = App.newDocument(f"{Client_Name}_{Site_Number}")

        main_file = f"C:/Users/weshu/OneDrive/Desktop/IMPACT Assets/Big Rework/Temp/{Client_Name}_{Site_Number}.FCStd"
        doc.saveAs(main_file)
        
        
        if ramp: 
        	Drop_Slope = int(Drop_Slope) if Drop_Slope else None
        	Drop_Angle = int(Drop_Angle) if Drop_Angle else None
        
        if deck:
            Deck_Length = int(Deck_Length)
            Deck_Width = int(Deck_Width)
            Stair_Number = int(Stair_Number)
            self.deck_designer_window = DeckDesignerWindow(
                main_file,Deck_Length, Deck_Width, Stair_Number, Inches_Deck,ramp, 
                self.macro_dir, 
                parent=self
            )
            print("Deck Designer active. Main script frozen...")
            self.deck_designer_window.exec_() 
            print("Deck Designer closed. Resuming script...")
            
            print("Launched Deck Designer Window.")
        
        if ramp:
            Gui.Control.closeDialog()
            print(12390)
            ramp_instance=ramp_class(main_file,Ramp_Desc,Flat_Check,Drop_Slope,Drop_Angle,Client_Name,Site_Number)
            print(132)
        
        for _ in range(20): # Give it 1 full second
            QtCore.QCoreApplication.processEvents()
            time.sleep(0.05)
        doc.recompute()
        
        if ramp and deck:
            doc = App.openDocument(main_file)
            try:
                import Assembly
                # Some versions require the Workbench to be initialized to register types
                if App.GuiUp:
                    Gui.activateWorkbench("AssemblyWorkbench")
                
            except ImportError:
                App.Console.PrintError("Assembly Workbench not found. Please ensure FreeCAD 1.0+ is installed.\n")
        
            try:
                asm = doc.addObject("Assembly::AssemblyObject", "Master")
                doc.recompute()
            except Exception as e:
                App.Console.PrintError(f"Error creating assembly object: {str(e)}\n")
            
            doc.recompute()
            deck_asm = doc.getObject("Deck")
            asm.addObject(deck_asm)
            for obj in doc.Objects:
                if obj.Label == "Ramp":
                    print(f"Found object: {obj.Name} ({obj.Label})")
                    ramp_obj = obj
            #ramp_asm = doc.getObject("Ramp")
            asm.addObject(ramp_obj)
            
            self.deck_designer_window.ground_joint(asm,doc,deck_asm)
            link_a=ramp_instance.partlist[0]
            sub_asm_obj_a = link_a.LinkedObject.Group[3].Name
            path_a = f"{ramp_obj.Name}.{link_a.Name}.{sub_asm_obj_a}.Face4"
            self.deck_designer_window.joint_ramp_deck(asm,doc,path_a)
        
       
       

# deck break out
class DeckDesignerWindow(QtGui.QDialog):
    def __init__(self, main_file, deck_length, deck_width, stair_count, inch, ramp, macro_dir, parent=None): # <-- FIX: Added macro_dir
        super(DeckDesignerWindow, self).__init__(parent)
        self.setWindowTitle(f"Deck Designer - {deck_length} x {deck_width}")
        self.setGeometry(200, 200, 1000, 800)
        
        self.main_file=main_file

        self.inch_unit=inch
        self.deck_length = deck_length
        self.deck_width = deck_width
        self.stair_count = stair_count
        self.macro_dir = macro_dir # <-- FIX: Save the path
        self.ramp = ramp
        
        self.ramp_item = None
        self.stair_items = []
        self.house_label_item = None  
        self.deck_rect = None       

        #self.central_widget = QtGui.QWidget()
        #self.setCentralWidget(self.central_widget)
        #self.master_layout = QtGui.QVBoxLayout(self.central_widget)
        
        self.master_layout = QtGui.QVBoxLayout(self) # Apply layout directly to self
        
        self.create_design_space()
        
    def create_design_space(self):
        title_label = QtGui.QLabel("<h2>Deck and Ramp Placement (Top View)</h2>")
        self.master_layout.addWidget(title_label)
        
        # Control Group
        control_group = QtGui.QGroupBox("Design Controls")
        control_layout = QtGui.QHBoxLayout(control_group)
        
        control_layout.addWidget(QtGui.QLabel("House Facing Side:"))
        self.house_side_combo = QtGui.QComboBox()
        self.house_side_combo.addItems(["Top", "Bottom", "Left", "Right"])
        self.house_side_combo.currentTextChanged.connect(self.update_house_label)
        control_layout.addWidget(self.house_side_combo)
        
        control_layout.addStretch(1)
        
        self.build_button = QtGui.QPushButton("Build 3D Model")
        self.build_button.setStyleSheet("background-color: #4CAF50; color: white; padding: 8px; font-weight: bold;")
        self.build_button.clicked.connect(self.build_in_freecad)
        control_layout.addWidget(self.build_button)
        
        self.master_layout.addWidget(control_group)

        # Scene and View
        self.scene = QtGui.QGraphicsScene()
        self.view = QtGui.QGraphicsView(self.scene)
        self.view.setRenderHint(QtGui.QPainter.Antialiasing)
        # Background color for a cleaner "Drafting" look
        self.view.setBackgroundBrush(QtGui.QBrush(QtGui.QColor(240, 240, 240))) 
        self.master_layout.addWidget(self.view)

        self.draw_deck()
        self.add_components()
        self.update_house_label(self.house_side_combo.currentText())
        
        
        
    def resizeEvent(self, event):
        """ This ensures the deck scales when the window is resized. """
        super(DeckDesignerWindow, self).resizeEvent(event)
        if hasattr(self, 'scene'):
            # Fit the deck in view while maintaining aspect ratio
            self.view.fitInView(self.scene.sceneRect(), QtCore.Qt.KeepAspectRatio)

    def update_house_label(self, side: str):
        # 1. Safe check for the item
        if hasattr(self, 'house_label_item') and self.house_label_item:
            self.scene.removeItem(self.house_label_item)
            self.house_label_item = None
            
        if not hasattr(self, 'deck_rect') or not self.deck_rect:
            return

        deck_rect = self.deck_rect.rect()
        
        # 2. Dynamic Font Scaling (approx 6% of the smallest deck dimension)
        reference_dim = min(deck_rect.width(), deck_rect.height())
        font_size = max(12, int(reference_dim * 0.06)) 
        
        label = QtGui.QGraphicsTextItem("HOUSE")
        label.setDefaultTextColor(QtGui.QColor(255, 0, 0))
        font = QtGui.QFont("Arial", font_size, QtGui.QFont.Bold)
        label.setFont(font)
        
        # 3. FIX: Set rotation point to center of the text
        label_bounds = label.boundingRect()
        label.setTransformOriginPoint(label_bounds.center())
        
        # Margin based on font size to keep it clean
        margin = font_size * 0.5 

        # 4. Position Logic
        if side == "Top":
            x = deck_rect.left() + (deck_rect.width() - label_bounds.width()) / 2
            y = deck_rect.top() - label_bounds.height() - margin
        elif side == "Bottom":
            x = deck_rect.left() + (deck_rect.width() - label_bounds.width()) / 2
            y = deck_rect.bottom() + margin
        elif side == "Left":
            label.setRotation(-90)
            # Center vertically, place to the left of the deck edge
            x = deck_rect.left() - label_bounds.width() - margin
            y = deck_rect.top() + (deck_rect.height() - label_bounds.height()) / 2
        elif side == "Right":
            label.setRotation(90)
            # Center vertically, place to the right of the deck edge
            x = deck_rect.right() + margin
            y = deck_rect.top() + (deck_rect.height() - label_bounds.height()) / 2

        label.setPos(x, y)
        self.scene.addItem(label)
        self.house_label_item = label
        
        # 5. Expand scene rect so the label doesn't get cut off during fitInView
        self.scene.setSceneRect(self.scene.itemsBoundingRect().adjusted(-50, -50, 50, 50))
        
    def draw_deck(self):
        """Clears the scene and draws the main deck rectangle with textures and labels."""
        self.scene.clear()
        
        # 1. Determine Scale (Inches vs Feet)
        # If inch_unit is True, we treat units as 1:1. If False (Feet), we scale by 12.
        SCALE = 1 if self.inch_unit else 12
        
        visual_length = self.deck_length * SCALE
        visual_width = self.deck_width * SCALE
        
        # 2. Setup Texture/Brush
        try:
            texture_path = os.path.join(self.macro_dir, "Decking.png")
            texture_pixmap = QtGui.QPixmap(texture_path)
            
            if texture_pixmap.isNull():
                # Fallback to a professional "blueprint" blue if image is missing
                deck_brush = QtGui.QBrush(QtGui.QColor(100, 150, 200, 150))
            else:
                # Tile the texture or scale it to fit the deck area
                scaled_pixmap = texture_pixmap.scaled(
                    visual_length, visual_width,
                    QtCore.Qt.IgnoreAspectRatio, QtCore.Qt.SmoothTransformation
                )
                deck_brush = QtGui.QBrush(scaled_pixmap)
                
        except Exception as e:
            print(f"Error loading texture: {e}. Falling back to solid color.")
            deck_brush = QtGui.QBrush(QtGui.QColor(200, 200, 200))

        # 3. Create the Deck Rectangle
        self.deck_rect = QtGui.QGraphicsRectItem(0, 0, visual_length, visual_width)
        self.deck_rect.setBrush(deck_brush)
        self.deck_rect.setPen(QtGui.QPen(QtCore.Qt.black, 2)) # Stronger border
        self.scene.addItem(self.deck_rect)
        
        # 4. Add the Area Label (Centered)
        label_text = f"DECK AREA\n{self.deck_length}' x {self.deck_width}'"
        label = QtGui.QGraphicsTextItem(label_text)
        
        # Dynamic font size for the center label (approx 5% of deck height)
        center_font_size = max(10, int(visual_width * 0.05))
        label.setFont(QtGui.QFont("Arial", center_font_size, QtGui.QFont.Bold))
        label.setDefaultTextColor(QtGui.QColor(20, 20, 20))
        
        # Center the label inside the deck
        label_rect = label.boundingRect()
        label.setPos(
            (visual_length - label_rect.width()) / 2,
            (visual_width - label_rect.height()) / 2
        )
        self.scene.addItem(label)
        
        # 5. Scene Boundary Logic
        # We adjust the scene rect by -100 to +100 to give room for the "HOUSE" label 
        # and stairs to exist outside the deck perimeter.
        self.scene.setSceneRect(self.deck_rect.rect().adjusted(-100, -100, 100, 100))
        
        # Force the view to update and center the new deck
        self.view.fitInView(self.scene.sceneRect(), QtCore.Qt.KeepAspectRatio)
    
    
    def add_components(self):
        deck_item = self.deck_rect
        
        if self.stair_count > 0:
            print(self.ramp)
            initial_x_offset = 0
            for i in range(self.stair_count):
                stairs = StairsItem(self.inch_unit, index=i + 1, deck_item=deck_item, macro_dir=self.macro_dir)
                stairs.setPos(initial_x_offset, 0)
                initial_x_offset += stairs.boundingRect().width()
                self.scene.addItem(stairs)
                self.stair_items.append(stairs)
        if self.ramp:
	        ramp = RampItem(self.inch_unit, deck_item=deck_item, macro_dir=self.macro_dir)
	        ramp_x_pos = deck_item.rect().width() - ramp.boundingRect().width()
	        ramp.setPos(ramp_x_pos, 0)
	        self.scene.addItem(ramp)
	        self.ramp_item = ramp
    
    def make_post(self,doc,asm,name):
        body = doc.addObject('PartDesign::Body', f"{name}")
        asm.addObject(body)
        sketch = doc.addObject('Sketcher::SketchObject', 'PostSketch')
        body.addObject(sketch) # This makes it a child of the assembly
        #
        dim = 3.5 * 25.4 
        lines = [
        Part.LineSegment(App.Vector(0, 0, 0), App.Vector(dim, 0, 0)),
        Part.LineSegment(App.Vector(dim, 0, 0), App.Vector(dim, dim, 0)),
        Part.LineSegment(App.Vector(dim, dim, 0), App.Vector(0, dim, 0)),
        Part.LineSegment(App.Vector(0, dim, 0), App.Vector(0, 0, 0))
        ]
        for line in lines:
            sketch.addGeometry(line, False)
        sketch.addConstraint(Sketcher.Constraint('Coincident', 0, 2, 1, 1))
        sketch.addConstraint(Sketcher.Constraint('Coincident', 1, 2, 2, 1))
        sketch.addConstraint(Sketcher.Constraint('Coincident', 2, 2, 3, 1))
        sketch.addConstraint(Sketcher.Constraint('Coincident', 3, 2, 0, 1))
        sketch.addConstraint(Sketcher.Constraint('Horizontal', 0))
        sketch.addConstraint(Sketcher.Constraint('Vertical', 1))
        
        sketch.addConstraint(Sketcher.Constraint('DistanceX', 0, 1, 0, 2, dim))
        sketch.addConstraint(Sketcher.Constraint('DistanceY', 1, 1, 1, 2, dim))
        doc.recompute()
        
        pad = doc.addObject('PartDesign::Pad', f'{name}')
        pad.Profile = sketch
        body.addObject(pad)
        pad.Type = 4 
        pad.Length = 40.5 * 25.4 ############################################ HAND RAIL height
        pad.setExpression('Length2', f'Posts_deck.Post_{name}')
        doc.recompute()
    # send OBJ
    def ground_joint(self,asm,doc,part):
        
        if App.GuiUp:
            Gui.activateWorkbench("AssemblyWorkbench")
        # Puts the assembly into 'edit' context so it can receive constraints
            Gui.ActiveDocument.setEdit(asm)

        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(doc.Name, part.Name)
        
        
        is_already_grounded = getattr(part, "Grounded", False)
        if not is_already_grounded:
            try:
                Gui.runCommand('Assembly_ToggleGrounded',0)
                doc.recompute()
                print(f"Grounded the root element: {part.Name}\n")
            except Exception as e:
                print(f"Failed to ground {part.Name}: {str(e)}\n")
        else:
            print(f"{part.Label} was already grounded. Skipping toggle.")
            
            # Get (or create) the JointGroup
        joints_grp = find_joint_group(asm)
        if joints_grp is None:
            doc.recompute()
            joints_grp = find_joint_group(asm)
            if joints_grp is None:
        # Fallback: create the Joints container if this build didn't auto-create it
                joints_grp = doc.addObject("Assembly::JointGroup", "Joints")
                asm.Group = asm.Group + [joints_grp]
                doc.recompute()

# Activate the Assembly WB so joint commands are available and land in the master
        if App.GuiUp:
            Gui.activateWorkbench("AssemblyWorkbench")
            try:
                Gui.ActiveDocument.setEdit(asm)  # set master assembly as active edit context
            except Exception:
                pass
        else:
            raise RuntimeError("Assembly joint creation requires FreeCAD running with GUI up.")

    # X Y Z
    def make_joint(self,asm,doc,itemA,itemB,offsetX,offsetY,offsetZ,rotX=0, rotY=0, rotZ=0):
        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(doc.Name,'Deck',itemA)
        Gui.Selection.addSelection(doc.Name,'Deck',itemB)
        QtCore.QCoreApplication.processEvents()
        time.sleep(0.1)
        try:
        # 2. Trigger the command
            Gui.runCommand('Assembly_CreateJointFixed')
        # 3. Wait for the Task Panel to be registered
        # We use a short loop to ensure the GUI is ready
            while Gui.Control.activeDialog():
            # Crucial: This allows the GUI to remain responsive to your clicks
                QtCore.QCoreApplication.processEvents()
                time.sleep(0.05)
                mw = Gui.getMainWindow()
        # Send 'Enter' key event to the main window/active focus
                buttons = mw.findChildren(QtGui.QPushButton)
                for btn in buttons:                
                    if btn.text() == "OK":
                        print("click")
                        btn.animateClick()
                        btn.click()
                        
                        found_button = True
                        break

        except Exception as e:
            print(f"Error at Joint {i}: {str(e)}")
            if Gui.Control.activeDialog():
                Gui.Control.closeDialog() # 'False' acts as Cancel/Reject
        
        for _ in range(10):
            QtCore.QCoreApplication.processEvents()
            time.sleep(0.02)

        joint_grp=find_joint_group(asm)
        new_joint = joint_grp.Group[-1]
        rot = App.Rotation(rotZ, rotY, rotX)
        new_joint.Offset2 = App.Placement(App.Vector(offsetX* 25.4 , offsetY*25.4,offsetZ* 25.4), rot)
        Gui.Selection.clearSelection()
        
        
    
    def build_in_freecad(self):
        SCALE = 1 if self.inch_unit else 12
        
        right26=None
        left26=None
        top26=None
        bottom26=None

        # joists   
        if (self.deck_width == self.deck_length) or (self.deck_width > self.deck_length):
            joists_direct="width"
            num_of_joists=((self.deck_width * SCALE)//24)
            
            if (self.deck_width * SCALE) % 24:
                num_of_joists=((self.deck_width * SCALE) / 24) -1
            else:
                num_of_joists=((self.deck_width * SCALE)//24)
                
                
            
            spacing_joists=((self.deck_width * SCALE)-3) / (num_of_joists + 1) ############### -3 might be wrong \_('>')_/
        else:
            joists_direct="length"
            if (self.deck_width * SCALE) % 24:
                num_of_joists=((self.deck_width * SCALE) / 24) -1
            else:
                num_of_joists=((self.deck_width * SCALE)//24)
            spacing_joists=((self.deck_length * SCALE)-3) / (num_of_joists + 1) ############### -3 might be wrong \_('>')_/
        
        
        if (joists_direct == "length"):
            if self.ramp_item:
                if self.ramp_item.snapped_edge in ["Top","Bottom"]:
                    joists_length=((self.deck_length * SCALE) -8) * 25.4 ############ might be crazy wrong
                else:
                   joists_length=((self.deck_length * SCALE) -3) * 25.4
            else:
                joists_length=((self.deck_length * SCALE) -3) * 25.4
        else:
            if self.ramp_item:
               if self.ramp_item.snapped_edge in ["Right","Left"]:
                    joists_length=((self.deck_width * SCALE) -8) * 25.4 ########
               else:
                   joists_length=((self.deck_width * SCALE) -3) * 25.4
            else:
                joists_length=((self.deck_width * SCALE) -3) * 25.4
        print(f"joists_direct {joists_direct}   num_of_runners : {num_of_joists}  spacing_joists {spacing_joists} joists_length {joists_length}" )
        
        #
        # ops length needs to be shorten 1.5inches
        if self.ramp_item:
            # ramp self.ramp_item.snapped_edge
            if self.ramp_item.snapped_edge == "Right":
                right26 = ((self.deck_width * SCALE) -3)# width - 3 inches offset to mm
                left26 = (self.deck_width * SCALE)
                top26 = ((self.deck_length * SCALE) -3)
                bottom26 = ((self.deck_length * SCALE) -3)
            
            elif self.ramp_item.snapped_edge == "Left":
                left26 = ((self.deck_width * SCALE) -3) # width - 3 inches offset to mm
                right26 = (self.deck_width * SCALE)
                top26 = ((self.deck_length * SCALE) -3)
                bottom26 =((self.deck_length * SCALE) -3)
                
            elif self.ramp_item.snapped_edge == "top":
                top26 = ((self.deck_length * SCALE) -3)# width - 3 inches offset to mm
                
                
                
            elif self.ramp_item.snapped_edge == "bottom":
                top26 = ((self.deck_length * SCALE) -3)# width - 3 inches offset to mm    
        

            
        
        print(f"""
        
        ________{top26}_______
        |                    |
        |                    |
        {left26}             {right26}
        |                    |
        |                    |
        --------{bottom26}----
        
        """)    
        
        
        
        doc = App.openDocument(self.main_file)
        try:
            import Assembly
        # Some versions require the Workbench to be initialized to register types
            if App.GuiUp:
                Gui.activateWorkbench("AssemblyWorkbench")
                
        except ImportError:
            App.Console.PrintError("Assembly Workbench not found. Please ensure FreeCAD 1.0+ is installed.\n")
        
        try:
            asm = doc.addObject("Assembly::AssemblyObject", "Deck")
            doc.recompute()
    
        except Exception as e:
            App.Console.PrintError(f"Error creating assembly object: {str(e)}\n")
        # POST SHEET
        sheet = doc.addObject("Spreadsheet::Sheet", "Posts_deck")
        asm.addObject(sheet) 
        # main posts
        append_row(sheet,"TLP")
        TLP=self.make_post(doc,asm,"TLP")
        append_row(sheet,"TRP")
        TRP=self.make_post(doc,asm,"TRP")
        append_row(sheet,"BLP")
        BLP=self.make_post(doc,asm,"BLP")
        append_row(sheet,"BRP")
        BRP=self.make_post(doc,asm,"BRP")
        #main boards
        right26_obj = doc.addObject("Part::Box", "right26")
        right26_obj.Length = (right26 * 25.4)
        right26_obj.Width = (1.5*25.4)
        right26_obj.Height = (5.5*25.4)
        asm.addObject(right26_obj) 
        left26_obj = doc.addObject("Part::Box", "left26")
        left26_obj.Length = (left26 * 25.4)
        left26_obj.Width = (1.5*25.4)
        left26_obj.Height = (5.5*25.4)
        asm.addObject(left26_obj) 
        top26_obj = doc.addObject("Part::Box", "top26")
        top26_obj.Length = (top26 * 25.4)
        top26_obj.Width = (1.5*25.4)
        top26_obj.Height = (5.5*25.4)
        asm.addObject(top26_obj) 
        bottom26_obj = doc.addObject("Part::Box", "bottom26")
        bottom26_obj.Length = (bottom26 * 25.4)
        bottom26_obj.Width = (1.5*25.4)
        bottom26_obj.Height = (5.5*25.4)
        asm.addObject(bottom26_obj) 
        
        doc.recompute()
        Gui.Control.closeDialog()
       
        #self.ground_joint(asm,doc,top26_obj)
        #self.make_joint(doc,'left26.Face2','top26.Face4',(top26/2)-.75)
        base=""
        if self.ramp_item:
            if self.ramp_item.snapped_edge == "Right":
                # frame
                self.ground_joint(asm,doc,left26_obj)
                self.make_joint(asm,doc,'top26.Face2','left26.Face4',0,(left26/2)-.75,0)
                self.make_joint(asm,doc,'bottom26.Face2','left26.Face4',0,-(left26/2)+.75,0)
                self.make_joint(asm,doc,'right26.Face3','left26.Face4',0,0,top26-5)
                
                if joists_direct in "length":
                    base="top26.Face3"
                    base1="bottom26.Face4"
                else:
                    base="right26.Face3"
                    base1="left26.Face4"
                # jiost
                print(f"{joists_direct}")
                for i in range(num_of_joists):
                    joist = doc.addObject("Part::Box", f"joist_{i}")
                    joist.Length = (joists_length)
                    joist.Width = (1.5*25.4)
                    joist.Height = (5.5*25.4)
                    asm.addObject(joist) 

                    self.make_joint(asm,doc,f'joist_{i}.Face1',base,0,((spacing_joists*(i+1))-((right26/2)-.75)),0)
                    for _ in range(30):
                        QtCore.QCoreApplication.processEvents()
                        time.sleep(0.02)
                    doc.recompute()
                
                print("posts")
                # posts
                self.make_joint(asm,doc,'TLP.Face2','top26.Face3',40.5/2-2.75,(top26/2)-1.75,0,0,0,90)
                for _ in range(30):
                        QtCore.QCoreApplication.processEvents()
                        time.sleep(0.02)
                self.make_joint(asm,doc,'TRP.Face2','top26.Face3',40.5/2-2.75,-(top26/2)+1.75,0,0,0,90)
                for _ in range(30):
                        QtCore.QCoreApplication.processEvents()
                        time.sleep(0.02)
                self.make_joint(asm,doc,'BLP.Face4','bottom26.Face4',40.5/2-2.75,(bottom26/2)-1.75,0,0,0,90)
                for _ in range(30):
                        QtCore.QCoreApplication.processEvents()
                        time.sleep(0.02)
                self.make_joint(asm,doc,'BRP.Face4','bottom26.Face4',40.5/2-2.75,-(bottom26/2)+1.75,0,0,0,90)
                for _ in range(30):
                        QtCore.QCoreApplication.processEvents()
                        time.sleep(0.02)
                
                if self.ramp_item.offset_value == 0:
                    if self.ramp_item.snapped_corner == "Right-Top":
                        append_row(sheet,"Ramp_post_2")
                        TLP=self.make_post(doc,asm,"Ramp_post_2")
                        time.sleep(12)
                        self.make_joint(asm,doc,'Ramp_post_2.Face2','TRP.Face4',0,0,-48,0,0,0)
                        
                    elif self.ramp_item.snapped_corner == "Right-bottom":
                        append_row(sheet,"Ramp_post_2")
                        TLP=self.make_post(doc,asm,"Ramp_post_2")
                        self.make_joint(asm,doc,'Ramp_post_2.Face2','right26.Face4',40.5/2-2.75,-(right26/2)+1.75,0,0,0,90)	
                        
                        
                
                
                    
                
            
            # el if
            #
            #  if el
                print(f" RAMP LOG: {self.ramp_item.name} | Edge: {self.ramp_item.snapped_edge} | Offset: {self.ramp_item.offset_value} in from {self.ramp_item.snapped_corner}")
            elif self.ramp_item.snapped_edge == "Left":
                left26 = ((self.deck_width * SCALE) -3) # width - 3 inches offset to mm
                right26 = (self.deck_width * SCALE)
                top26 = ((self.deck_width * SCALE) -3)
                bottom26 =((self.deck_width * SCALE) -3)
                
            elif self.ramp_item.snapped_edge == "Top":
                top26 = ((self.deck_length * SCALE) -3) * 25.4 # width - 3 inches offset to mm
                
                
                
            elif self.ramp_item.snapped_edge == "Bottom":
                top26 = ((self.deck_length * SCALE) -3) * 25.4 # width - 3 inches offset to mm    
        

            
            
            
        # normal
        else:
            print("NORMAL")
        
        """
        support_width=False
        support_length=False
        
        support_extra=False
        shared_beam_post=None
        
        
        beam_die=None
        # extra
        if (self.deck_width * SCALE) > 96:
            support_width=True  
        if (self.deck_length * SCALE) > 96:
            support_length=True
            
        if (support_width):
            beam_die="Length"
        if (support_length) :
            beam_die="width"
        
        
        if support_width:
            if self.ramp_item:
                if self.ramp_item.snapped_edge in ["Top","Bottom"]:
                    support_extra=True
            
            if support_extra = =True:
                for i in self.stair_items:
                    if i.snapped_edge in ["Top","Bottom"]:
                        if self.ramp_item.snapped_edge != i.snapped_edge:
                            if self.ramp_item.offset_value == i.offset_value:
                                shared_beam_post=f"{i.Name}"
                                support_extra=False
                                
            print(shared_beam_post)            
        """            
    def joint_ramp_deck(self,asm,doc,path):
        itemA=path
        if self.ramp_item.snapped_edge == "Right":
            itemB='Deck.right26.Face4'
        offsetX=0
        offsetY=0
        offsetZ=0
        
        rotZ=0
        rotY=180
        rotX=0
        
        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(doc.Name,'Master',itemA)
        Gui.Selection.addSelection(doc.Name,'Master',itemB)
    
        QtCore.QCoreApplication.processEvents()
        time.sleep(0.1)
    
        try:
        # 2. Trigger the command
            Gui.runCommand('Assembly_CreateJointFixed')
        
        # 3. Wait for the Task Panel to be registered
        # We use a short loop to ensure the GUI is ready
            while Gui.Control.activeDialog():
            # Crucial: This allows the GUI to remain responsive to your clicks
                QtCore.QCoreApplication.processEvents()
                time.sleep(0.05)
                mw = Gui.getMainWindow()
        # Send 'Enter' key event to the main window/active focus
                buttons = mw.findChildren(QtGui.QPushButton)
                for btn in buttons:
                    
                    if btn.text() == "OK":
                        print("click")
                        btn.animateClick()
                        btn.click()
                        
                        found_button = True
                        break

        except Exception as e:
            print(f"Error at Joint {i}: {str(e)}")
            if Gui.Control.activeDialog():
                Gui.Control.closeDialog() # 'False' acts as Cancel/Reject
        
        for _ in range(10):
            QtCore.QCoreApplication.processEvents()
            time.sleep(0.02)

        joint_grp=find_joint_group(asm)
        new_joint = joint_grp.Group[-1]
        rot = App.Rotation(rotZ, rotY, rotX)
        new_joint.Offset2 = App.Placement(App.Vector(offsetX* 25.4 , offsetY*25.4,offsetZ* 25.4), rot)
        Gui.Selection.clearSelection()
        
        
            
        
        
        
class DraggableItem(QtGui.QGraphicsRectItem):
    def __init__(self, rect, color, name="Item", deck_item=None, texture_path=None, parent=None):
        super(DraggableItem, self).__init__(rect, parent)
        self.name = name
        self.deck_item = deck_item
        
        # --- Data Storage for Location Reporting ---
        self.snapped_edge = "None"    # Top, Bottom, Left, Right
        self.snapped_corner = "None"  # e.g., "Top-Left"
        self.offset_value = 0.0       # The user-defined inches
        
        self.setFlag(QtGui.QGraphicsRectItem.ItemIsMovable)
        self.setCacheMode(QtGui.QGraphicsRectItem.DeviceCoordinateCache)

        # --- Texture Loading Code ---
        brush = QtGui.QBrush(QtGui.QColor(color))
        if texture_path and os.path.exists(texture_path):
            try:
                texture_pixmap = QtGui.QPixmap(texture_path)
                if not texture_pixmap.isNull():
                    # Scale the texture to fit the specific item size (36x36, 48x48, etc)
                    scaled_pixmap = texture_pixmap.scaled(
                        rect.width(), rect.height(),
                        QtCore.Qt.IgnoreAspectRatio, QtCore.Qt.SmoothTransformation
                    )
                    brush = QtGui.QBrush(scaled_pixmap)
                else:
                    print(f"Warning: Pixmap null for {texture_path}")
            except Exception as e:
                print(f"Error loading texture: {e}")
        
        self.setBrush(brush)
        self.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0), 1))
        self.add_label()

    def get_snap_positions(self):
        """Defines the 8 anchor points relative to the deck edges."""
        if not self.deck_item:
            return []
        dr = self.deck_item.rect()
        iw = self.boundingRect().width()
        ih = self.boundingRect().height()
        
        # Returns (Coordinate, Name of the Anchor)
        return [
            (QtCore.QPointF(dr.left(), dr.top() - ih), "Top-Left"),
            (QtCore.QPointF(dr.left() - iw, dr.top()), "Left-Top"),
            (QtCore.QPointF(dr.right() - iw, dr.top() - ih), "Top-Right"),
            (QtCore.QPointF(dr.right(), dr.top()), "Right-Top"),
            (QtCore.QPointF(dr.right() - iw, dr.bottom()), "Bottom-Right"),
            (QtCore.QPointF(dr.right(), dr.bottom() - ih), "Right-Bottom"),
            (QtCore.QPointF(dr.left(), dr.bottom()), "Bottom-Left"),
            (QtCore.QPointF(dr.left() - iw, dr.bottom() - ih), "Left-Bottom")
        ]

    def mouseReleaseEvent(self, event):
        super(DraggableItem, self).mouseReleaseEvent(event)
        
        snaps = self.get_snap_positions()
        if not snaps: return

        # 1. Identify nearest anchor point
        cur = self.pos()
        min_dist = float('inf')
        nearest_pt = snaps[0][0]
        corner_name = snaps[0][1]

        for pt, name in snaps:
            dist = (pt.x() - cur.x())**2 + (pt.y() - cur.y())**2
            if dist < min_dist:
                min_dist = dist
                nearest_pt = pt
                corner_name = name

        self.setPos(nearest_pt.x(), nearest_pt.y())

        # 2. Get the offset from the user
        val, ok = QtGui.QInputDialog.getInt(
            None, "Placement", f"Inches from {corner_name}:", 
            int(self.offset_value), -500, 500, 1
        )
        if not ok: return

        # 3. Apply Offset Logic & Determine Edge
        fx, fy = nearest_pt.x(), nearest_pt.y()
        edge = corner_name.split('-')[0] 
        
        if edge in ["Top", "Bottom"]:
            # Move horizontally (Toward center)
            fx += float(val) if "Left" in corner_name else -float(val)
        else:
            # Move vertically (Toward center)
            fy += float(val) if "Top" in corner_name else -float(val)

        # 4. Save and Log Data
        self.setPos(QtCore.QPointF(fx, fy))
        self.snapped_edge = edge
        self.snapped_corner = corner_name
        self.offset_value = float(val)
        
        print(f"LOG: {self.name} | Edge: {self.snapped_edge} | Offset: {self.offset_value} in from {self.snapped_corner}")

    def add_label(self):
        label = QtGui.QGraphicsTextItem(self.name, parent=self)
        label.setDefaultTextColor(QtGui.QColor(0, 0, 0))
        item_rect = self.boundingRect()
        font_size = max(5, int(item_rect.height() * 0.15))
        font = QtGui.QFont("Arial", font_size, QtGui.QFont.Bold)
        label.setFont(font)
        lb = label.boundingRect()
        label.setPos(item_rect.width()/2 - lb.width()/2, item_rect.height()/2 - lb.height()/2)

class StairsItem(DraggableItem):
    # --- PATH FIX: Accept macro_dir and build full path ---
    def __init__(self, scale, index=1, deck_item=None, macro_dir="", parent=None):
        full_texture_path = os.path.join(macro_dir, "Stair_T.png")
        super(StairsItem, self).__init__(
            QtCore.QRectF(0, 0, 36, 36),
            QtGui.QColor(255, 150, 50, 200),
            f"STAIRS {index}",
            deck_item=deck_item,
            texture_path=full_texture_path, # Pass the full path
            parent=parent
        )
        
class RampItem(DraggableItem):
    # --- PATH FIX: Accept macro_dir and build full path ---
    def __init__(self,scale, deck_item=None, macro_dir="", parent=None):
            full_texture_path = os.path.join(macro_dir, "Ramp_T.png")
            super(RampItem, self).__init__(
                QtCore.QRectF(0, 0, 48, 48),
                QtGui.QColor(50, 200, 50, 200),
                "RAMP",
                deck_item=deck_item,
                texture_path=full_texture_path, # Pass the full path
                parent=parent
            )
    
class ramp_class():
    
    def __init__(self,main_file,desc,ending_flat,Drop_Slope,Drop_Angle,client,site_number):
        print(567)
        self.desc=desc
        self.ending_flat=ending_flat
        self.Drop_Slope=Drop_Slope
        self.Drop_Angle=Drop_Angle
        self.client=client
        self.site_number=site_number
        self.partlist = []
        self.partlist=self.ramp_main(main_file,desc,ending_flat,Drop_Slope,Drop_Angle,client,site_number)
        
    def ramp_main(self,main_file,desc,ending_flat,Drop_Slope,Drop_Angle,client,site_number):
            print(21)
            parts_to_import= {}
            parced_desc=desc.split(",")
            feet_of_ramp=0
            for i in parced_desc:
                if i == "8ft":
                    feet_of_ramp+=8
                elif i == "12ft":
                    feet_of_ramp+=12
                elif i == "16ft":
                    feet_of_ramp+=16
    
            # Slope
            if (Drop_Slope != None): # inch of feet
                angle_radians = math.atan(Drop_Slope / (feet_of_ramp*12))
                angle=math.degrees(angle_radians)
            else:
                angle=Drop_Angle
            
            doc = App.openDocument(main_file)
            asm = doc.addObject("Assembly::AssemblyObject", "Assembly")
            asm.Label = f"Ramp"
            doc.recompute()
            
            flat="LAN","TL","TR","UTURNL","UTURNR"
            ramp="8ft","12ft","16ft"
            boxes={}
            current_x = 0
            current_y = 0
            current_heading = 0
            #
            # Allways send angle
            # current_x, current_y, index, name, length=0, width=0, heading=0
            for index,part in enumerate(parced_desc):
                if index > 0:  	
                    part_before = parced_desc[index - 1]
                if index < len(parced_desc) - 1:
                    part_after = parced_desc[index + 1]
                # if part first
                print("inde x  "+str(index))
                if (index == 0):
                    current_x=0
                    current_y=0
                    if (part in ramp):
                        if (part_after in flat):
                            # 05_XX_05
                            parts_to_import[index]="A_"+part+"_A"
                            boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"A_"+part+"_A",current_heading)
                        elif (part_after in ramp):
                        # 05_XX
                            parts_to_import[index]="A_"+part
                            boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"A_"+part,current_heading)
                    else:
                        parts_to_import[index]=part
                        boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part,current_heading)
                # Last // ENDING   
                elif (index == len(parced_desc)-1):
                    if (part_before in flat):
                        # 05_XX_ ENDING
                        parts_to_import[index]="A_"+part+"_END"
                        boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"A_"+part+"_END",current_heading)
                    else:
                        # __XX_ ENDING
                        parts_to_import[index]=""+part+"_END"
                        boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part+"_END",current_heading)
                # normal
                # btween 2 flat
                elif (part_before in flat and part in ramp and part_after in flat):
                    # 05_XX_05
                    parts_to_import[index]="A_"+part+"_A"
                    boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"A_"+part+"_A",current_heading)
                # one side angled:
                elif (((part_before in flat) or (part_after in flat)) and part in ramp):
                    if (part_before in flat):
                        # 05_XX
                        parts_to_import[index]="_A"+part
                        boxes[f"{index}_{part}"]=Box(current_x,current_y,index,"_A"+part,current_heading)
                    else:
                        # XX_05
                        parts_to_import[index]=part+"_A"
                        boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part+"_A",current_heading)
                # XX normal RAMP
                elif (part_before in ramp and part in ramp and part_after in ramp):
                    parts_to_import[index]=part
                    boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part,current_heading)
                elif (part in flat):
                    # place flats
                    parts_to_import[index]=part
                    boxes[f"{index}_{part}"]=Box(current_x,current_y,index,part,current_heading)
                else:
                    print("NO NO NO NO - A part was NOT imported HELP HELP HELP"+part)
        # curs
        # should always be the top center line
        
        # patch for now
                current_y -= boxes[f"{index}_{part}"].length
        #current_x = boxes[f"{index}_{part}"].width
        
        
        # Do this in the class
            """
        length = boxes[f"{index}_{part}"].length
        width = boxes[f"{index}_{part}"].width

        # Compute movement and heading updates per part type
        if part in ("8ft", "12ft", "16ft", "LAN"):
        # Straight run or inline landing: advance full length
            #current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length, lateral=0.0)
            None

        elif part == "TL":
            # 90 left turn landing: half forward, then left by width/2, then rotate left
            current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length/2.0, lateral=+width/2.0)
            current_heading = (current_heading - 90) % 360

        elif part == "TR":
            # 90 right turn landing: half forward, then right by width/2, then rotate right
            current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length/2.0, lateral=-width/2.0)
            current_heading = (current_heading + 90) % 360

        elif part == "UTURN":
           # 180 turn landing: choose your intent.
           # Option A (exit from far edge center): full forward, then rotate 180
           current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length, lateral=0.0)
           current_heading = (current_heading + 180) % 360

           # Option B (exit from midline): half forward, rotate 180
           # current_x, current_y = advance_cursor(current_x, current_y, current_heading,forward=length/2.0, lateral=0.0)
           # current_heading = (current_heading + 180) % 360

        else:
           print("Unknown part type for cursor logic:", part)
           
            """
            # List for imported links into master
            part_links = []
            # RAMP POST alg
            # Create a SET of 
            print("importin")
            for key,value in parts_to_import.items():
                if  "8ft" in value:
                    if "A_8ft_A" == value:
                        new_link = import_ramp_part(main_file,key,"8ft",angle,angle)
                    elif "A_8ft" == value:
                        new_link = import_ramp_part(main_file,key,"8ft",angle,0)
                    elif "8ft_A" == value:
                        new_link = import_ramp_part(main_file,key,"8ft",0,angle)
                    elif "8ft" == value:
                        new_link = import_ramp_part(main_file,key,"8ft",0,0)
                    elif "END" in value:
                        #A_"+part+"END
                        #"+part+"END
                        if ending_flat:
                            if "A_8ft_END" == value:
                                print("you NEED TO ADD THIS")
                            elif "8ft_END" == value:
                                print("you NEED TO ADD THIS")
                            else:
                                print("BAD BAD BAD : "+value)
                        else:
                            if "A_8ft_END":
                                print("someing")
                            elif "8ft_END":
                                print("see")
                            else:
                                print("BAD BAD BAD : "+value)
                    else:
                        print("BAD BAD BAD : "+value)
                elif  "12ft" in value:
                    print("hui")
                elif  "16ft" in value:
                    print("hui")       
                # Add link to be connected
                if new_link:
                    part_links.append(new_link)
            #So like testing the post thing now
            temp_post_big = {}
            for name,box in boxes.items():
                for key,value in box.cords.items():
                    if value != None:
                        temp_post_big[f"{name}_{key}"]=value
            post_final={}
            seen_points = set()
            for key,val in temp_post_big.items():
                point_tuple = (val['x'], val['y'])
                if point_tuple not in seen_points:
                    post_final[key] = val
                    seen_points.add(point_tuple)
            for k,v in post_final.items():
                print(f"{k}: {v}")
            # get posts to set to box 
            # create post stuff??
            # create spreadsheet
            doc = App.activeDocument()
            assembly = None
            for obj in doc.Objects:
                if "Assembly" in obj.Label or obj.isDerivedFrom("App::Part"):
                    assembly = obj
                    break
                if not assembly:
                    print("Assembly object not found.")
                    return
            sheet = doc.addObject("Spreadsheet::Sheet", "Posts_Ramp")
            assembly.addObject(sheet)
            for name,points in post_final.items():
                append_row(sheet,name)
                make_post_sketch(main_file,name,angle)
                # schetch? -> spreadsheet -> pan (extend) 2 ways one as var -> draft on face based on angle
            #assemble main assembly
            # GROUND @####################
            first_link = part_links[0]
            doc = FreeCAD.ActiveDocument
            if doc is None:
                raise RuntimeError("No active FreeCAD document.")
            # Helper to find the JointGroup ("Joints" container) under the assembly
            def find_joint_group(asm_obj):
                for child in getattr(asm_obj, "Group", []):
                    tid = getattr(child, "TypeId", "")
                    if tid == "Assembly::JointGroup" or child.isDerivedFrom("Assembly::JointGroup"):
                        return child
                return None
            if App.GuiUp:
                Gui.activateWorkbench("AssemblyWorkbench")
                Gui.ActiveDocument.setEdit(asm)
            
            Gui.Selection.clearSelection()
            Gui.Selection.addSelection(doc.Name, first_link.Name)
            is_already_grounded = getattr(first_link, "Grounded", False)
            if not is_already_grounded:
                try:
                    Gui.runCommand('Assembly_ToggleGrounded',0)
                    doc.recompute()
                    print(f"Grounded the root element: {first_link.Name}\n")
                except Exception as e:
                    print(f"Failed to ground {first_link.Name}: {str(e)}\n")
            else:
                print(f"{first_link.Label} was already grounded. Skipping toggle.")
            joints_grp = find_joint_group(asm)
            if joints_grp is None:
                doc.recompute()
                joints_grp = find_joint_group(asm)
                if joints_grp is None:
                    joints_grp = doc.addObject("Assembly::JointGroup", "Joints")
                    asm.Group = asm.Group + [joints_grp]
                    doc.recompute()
            if App.GuiUp:
                Gui.activateWorkbench("AssemblyWorkbench")
                Gui.ActiveDocument.setEdit(asm)
            # --- Loop: create Fixed joints between consecutive master links ----------------
            for i in range(len(part_links) - 1):
                link_a = part_links[i]
                link_b = part_links[i + 1]
                
                sub_asm_obj_a = link_a.LinkedObject.Group[4].Name
                sub_asm_obj_b = link_b.LinkedObject.Group[3].Name 
                
                path_a = f"{link_a.Name}.{sub_asm_obj_a}.Face4"
                path_b = f"{link_b.Name}.{sub_asm_obj_b}.Face4"
                
                print(sub_asm_obj_a+" "+ sub_asm_obj_b)
                if link_a.Name == link_b.Name:
                    continue
                Gui.Selection.clearSelection()
                Gui.Selection.addSelection(doc.Name, 'Assembly', path_a)
                Gui.Selection.addSelection(doc.Name, 'Assembly', path_b)
                # Let the GUI thread process the selection
                QtCore.QCoreApplication.processEvents()
                time.sleep(0.1)
                try:
                    Gui.runCommand('Assembly_CreateJointFixed')
                    while Gui.Control.activeDialog():
                        QtCore.QCoreApplication.processEvents()
                        time.sleep(0.05)
                        mw = Gui.getMainWindow()
                        buttons = mw.findChildren(QtGui.QPushButton)
                        for btn in buttons:
                            if btn.text() == "OK":
                                btn.click() # This is a direct Qt click signal
                                found_button = True
                                break
                except Exception as e:
                    print(f"Error at Joint {i}: {str(e)}")
                    if Gui.Control.activeDialog():
                        Gui.Control.closeDialog() # 'False' acts as Cancel/Reject
                for _ in range(10):
                    QtCore.QCoreApplication.processEvents()
                    time.sleep(0.02)
            print("RAMP DONE _______________")
            return part_links
    
    
    
    
    
    
    
    
    
    
    
    
    
    


def import_ramp_part(main_file_path, index, part, start_angle, end_angle):
    # 1. Setup paths
    source_file = r"C:\Users\weshu\OneDrive\Desktop\IMPACT Assets\Big Rework\Parts\All parts made\8ft_Main.FCStd"
    temp_file = f"C:/Users/weshu/OneDrive/Desktop/IMPACT Assets/Big Rework/Temp/{index}_{part}.FCStd"
    nested_link = None
    # 2. Create the modified part file
    # We open the source, save a copy, close source, open the copy
    src_doc = App.openDocument(source_file)
    src_doc.saveCopy(temp_file)
    App.closeDocument(src_doc.Name)
    
    sub_doc = App.openDocument(temp_file)
    
    # 3. Update Spreadsheet values
    sheet = sub_doc.getObject("Spreadsheet")
    if sheet:
        sheet.set("start_angle", str(start_angle))
        sheet.set("end_angle", str(end_angle))
        sub_doc.recompute()
    sub_doc.save() # Ensure changes are written to disk

    # 4. Get the Main Assembly Document
    # Use openDocument to get the object, then ensure we have the Assembly container
    main_doc = App.openDocument(main_file_path)
    main_asm = main_doc.getObject("Assembly") # This is the object we created in the last step
    
    if not main_asm:
        print("Error: Main Assembly container not found in the main file.")
        return

    # 5. Create a Link to the sub-document's content
    # In the integrated workbench, we usually link the 'Assembly' object of the sub-file
    sub_asm_obj = None
    for obj in sub_doc.Objects:
        # Check for the correct type we discovered: Assembly::AssemblyObject
        if obj.isDerivedFrom("Assembly::AssemblyObject"):
            sub_asm_obj = obj
            break

    if sub_asm_obj:
        # Create an App::Link in the Main Document
        link_name = f"Link_{part}_{index}"
        nested_link = main_doc.addObject("App::Link", link_name)
        nested_link.LinkedObject = sub_asm_obj
        
        # Move the link into the Main Assembly container
        main_asm.Group = main_asm.Group + [nested_link]
    
        print(f"Successfully linked {part} into Main Assembly.")
    else:
        print(f"Could not find a valid object to link in {temp_file}")

    main_doc.recompute()
    main_doc.save()
    return nested_link

def append_row(sheet_obj, name):
    #Finds the first empty row in column A and writes the data_list across that row.
    row = 1
    # Find the first row where Column A is empty
    while sheet_obj.getContents(f"A{row}"):
        row += 1
    sheet_obj.set(f"A{row}", name)
    sheet_obj.set(f"B{row}", "1")
    sheet_obj.setAlias(f"B{row}", f"Post_{name}")
    
    App.activeDocument().recompute()     

def make_post_sketch(main_file,name,angle=0):
    doc = App.activeDocument()
    assembly = None
    for obj in doc.Objects:
        if "Assembly" in obj.Label or obj.isDerivedFrom("App::Part"):
            assembly = obj
            break
    
    if not assembly:
        print("Assembly object not found.")
        return
    
    body = doc.addObject('PartDesign::Body', 'Post_Body')
    assembly.addObject(body)
    
    sketch = doc.addObject('Sketcher::SketchObject', 'PostSketch')
    body.addObject(sketch) # This makes it a child of the assembly
    
    dim = 3.5 * 25.4 
    
    # Create line segments
    lines = [
        Part.LineSegment(App.Vector(0, 0, 0), App.Vector(dim, 0, 0)),
        Part.LineSegment(App.Vector(dim, 0, 0), App.Vector(dim, dim, 0)),
        Part.LineSegment(App.Vector(dim, dim, 0), App.Vector(0, dim, 0)),
        Part.LineSegment(App.Vector(0, dim, 0), App.Vector(0, 0, 0))
    ]
    
    for line in lines:
        sketch.addGeometry(line, False)

    # 4. Add Constraints
    # Connect corners (Coincident)
    sketch.addConstraint(Sketcher.Constraint('Coincident', 0, 2, 1, 1))
    sketch.addConstraint(Sketcher.Constraint('Coincident', 1, 2, 2, 1))
    sketch.addConstraint(Sketcher.Constraint('Coincident', 2, 2, 3, 1))
    sketch.addConstraint(Sketcher.Constraint('Coincident', 3, 2, 0, 1))
    
    # Ensure lines are square
    sketch.addConstraint(Sketcher.Constraint('Horizontal', 0))
    sketch.addConstraint(Sketcher.Constraint('Vertical', 1))
    
    # Set Dimensions to 3.5 inches
    sketch.addConstraint(Sketcher.Constraint('DistanceX', 0, 1, 0, 2, dim))
    sketch.addConstraint(Sketcher.Constraint('DistanceY', 1, 1, 1, 2, dim))
    
    doc.recompute()
    
    pad = doc.addObject('PartDesign::Pad', f'{name}')
    pad.Profile = sketch
    body.addObject(pad)
    
    pad.Type = 4 
    
    # Direction 1: 5 inches up
    pad.Length = 29.0 * 25.4
    
    # Direction 2: 2 inches down
    pad.setExpression('Length2', f'Posts_Ramp.Post_{name}')
    
    doc.recompute()
    flat="LAN","TR","TL","UTURNR","UTURNL"
    if angle != 0 and name not in flat:
        draft = doc.addObject('PartDesign::Draft', f'Draft_{name}')
        body.addObject(draft)
        
        # Define which face to draft. 
        # Typically, for a Pad, Face6 is one of the vertical side faces.
        draft.Base = (pad, ["Face6"])
        
        # PullDirection is the vector along which the draft is measured (usually Z)
        #draft.PullDirection = (pad, ["Edge10"]) # Using a face to define the normal
        
        #draft.NeutralPlane = (pad, ["Face5"])
        
        draft.Angle = angle
        draft.Reversed = True # Matches your recorded macro
        
        doc.recompute()

#   I PROB DONT NEED TGHIS
def advance_cursor(x, y, heading_deg, forward, lateral=0.0):
    rad = math.radians(heading_deg)

    # Forward along heading
    x_fwd = x + forward * math.cos(rad)
    y_fwd = y + forward * math.sin(rad)

    # Lateral left/right (left is +, right is -)
    # Left vector = heading rotated +90  (-sin, +cos)
    x_lat = x_fwd + lateral * (-math.sin(rad))
    y_lat = y_fwd + lateral * ( math.cos(rad))

    return x_lat, y_lat
    
#
# MAIN
#
class RampBuilderPanel:
    def __init__(self):
        self.form = MainForm()
panel_wrapper = RampBuilderPanel() 
FreeCADGui.Control.showDialog(panel_wrapper)
